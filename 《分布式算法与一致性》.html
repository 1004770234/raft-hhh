<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603139 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="35005"/>

<div>
<span><div><br/></div><div>0、相关资料：</div><div>    ①P210：论文作者Maurice写的一本书：《The Art of Multiprecessor Programming》</div><div>    ②P216：wiki中对线性一致性的描述</div><div>    ③P218：区别【线性一致性与顺序一致性】<a href="https://www.dazhuanlan.com/if2521/topics/1602229" style="font-size: unset; font-family: unset;">https://www.dazhuanlan.com/if2521/topics/1602229</a></div><div>1、<span style="font-size: unset; color: unset; font-family: unset;">重点：217</span></div><div>2、问题：217、222、232、</div><div>    【线性一致性和顺序一致性的设计区别？为什么一个单节点，一个节点间】</div><div>3、原文错误：211、215、</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>【<span style="font-size: 12pt; color: rgb(50, 135, 18); font-weight: bold;">P210</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">-第15章：线性一致性与强一致性</span>】</div><div>【<span style="font-size: 12pt; color: rgb(50, 135, 18); font-weight: bold;">P225</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">-第16章：结构设计中的权衡</span>】</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>【<span style="font-size: 12pt; color: rgb(50, 135, 18); font-weight: bold;">P210</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">-第15章：线性一致性与强一致性</span>】</div><div><br/></div><div>210、①阅读原始论文：本书省略了很多内容，<span style="color: rgb(222, 87, 0); font-weight: bold;">因为给出原文，会引出很多新的概念需要展开解释</span></div><div>②论文作者Maurice写的一本书：《The Art of Multiprecessor Programming》</div><div>③<span style="color: rgb(227, 0, 0); font-weight: bold;">论文中有2处错误，一处无伤大雅，另一个会 影响对线性一致性的理解</span></div><div><br/></div><div>211、①操作：调用+返回</div><div>②历史（history）：</div><div>    有限个操作的【调用事件和返回事件】组成的序列</div><div>③匹配：</div><div>    同一个操作的调用事件和返回事件是匹配的</div><div>④顺序：</div><div>    【1】其实和顺序一致性中的sequential是同一个意思</div><div>    <span style="color: rgb(222, 87, 0); font-weight: bold;">【2】只不过论文里给了更明确的定义</span></div><div>⑤一个历史H在下面的条件下是顺序的</div><div>    【1】H的第一个事件时调用事件</div><div>    【2】<span style="color: rgb(50, 135, 18); font-weight: bold;">除了最后一个事件，每个【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">调用事件</span><span style="color: rgb(50, 135, 18); font-weight: bold;">】后面都紧跟着【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">匹配的返回事件</span><span style="color: rgb(50, 135, 18); font-weight: bold;">】每个返回事件后面都紧跟着一个</span><span style="color: rgb(227, 0, 0); font-weight: bold;">匹配的</span><span style="color: rgb(50, 135, 18); font-weight: bold;">调用事件。</span></div><div><span style="color: rgb(50, 135, 18); font-weight: bold;">（</span><span style="color: rgb(227, 0, 0); font-weight: bold;">这里是原文错误，应该是“其他的”，而不是“匹配的”</span><span style="color: rgb(50, 135, 18); font-weight: bold;">）</span></div><div>⑥偏序：</div><div>    如果<span style="color: rgb(222, 87, 0); font-weight: bold;">操作【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">e0的</span><span style="color: rgb(222, 87, 0); font-weight: bold;">返回事件</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】在操作【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">e1的</span><span style="color: rgb(222, 87, 0); font-weight: bold;">调用事件</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】之前</span>，那么e0和e1就存在偏序关系。</div><div>⑦子历史：</div><div>    历史H中，某个进程的【所有调用事件和返回事件】组成的【<span style="color: rgb(50, 135, 18); font-weight: bold;">子序列</span>】</div><div>⑧<span style="color: rgb(222, 87, 0); font-weight: bold;">complete（H）</span>：</div><div>    仅仅包含【调用事件和匹配的返回事件】的【最大子序列】</div><div>⑨等价的</div><div>    两个历史H和H'，如果历史H的<span style="color: rgb(222, 87, 0); font-weight: bold;">每个进程的</span>【子历史】和历史H'的进程【子历史】相等</div><div><br/></div><div>213、①<span style="color: rgb(50, 135, 18); font-weight: bold;">线性一致性-定义</span>：</div><div>一个历史H，如果能够通过【在末尾添加返回事件成为历史H'】，并且历史H'满足以下两个条件：</div><div>    【1】complete（H'）等价于【<span style="color: rgb(222, 87, 0); font-weight: bold;">某个</span>】合法的顺序历史S</div><div>    【2】H中的偏序关系在S中也存在</div><div>②历史H：</div><div>    如果存在一个观测到的执行，那么按这个执行中的每个【<span style="color: rgb(222, 87, 0); font-weight: bold;">调用事件和返回事件的“实际执行时间”</span>】构成的一个事件序列</div><div>③如何得到S：</div><div>    【1】<span style="color: rgb(222, 87, 0); font-weight: bold;">排列组合</span>所有的事件，从中找到符合顺序要求的历史</div><div>    【2】如果找到的历史也是<span style="color: rgb(222, 87, 0); font-weight: bold;">合法</span>的，那么这个历史就可以是S</div><div><br/></div><div>214、①一个系统满足【线性一致性】，那么这个系统【<span style="color: rgb(222, 87, 0); font-weight: bold;">所有可能的实际执行的历史</span>】都必须是【线性】的</div><div>②问题转化：判断一个历史是否是线性一致性的</div><div>③例子——判断一个【先进先出的队列】是否是线性一致性的。</div><div>④E(A)：对变量x进行入队</div><div>D(x)：对变量x进行出队</div><div>ok()B ：客户端B的某个操作的返回事件</div><div>⑤组合排列，得到历史S——【<span style="color: rgb(50, 135, 18); font-weight: bold;">本质：把所有操作的“返回事件ok()”紧跟在操作后面</span>】</div><div><br/></div><div>215、①<span style="color: rgb(227, 0, 0); font-weight: bold;">错误：【1】D(x)应该为D(x)B</span></div><div><span style="color: rgb(227, 0, 0); font-weight: bold;">                    【2】D(y)应该为D(y)A</span></div><div>②<span style="color: rgb(50, 135, 18); font-weight: bold;">问题：历史S【不合法】</span>，一个队列，先入队x，那么一定要先出队x</div><div><br/></div><div>216、【<span style="color: rgb(227, 0, 0); font-weight: bold;">线性一致性+强一致性</span>】</div><div>①【<span style="color: rgb(227, 0, 0); font-weight: bold;">wiki中</span>】线性一致性 ：</div><div>    【1】对于历史中每个完成的【操作】，<span style="color: rgb(222, 87, 0); font-weight: bold;">【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">该操作返回的结果】与【每个操作一个接一个地完成返回的结果</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】</span>，相同</div><div>    【2】如果操作op1在操作op2开始之前完成（<span style="color: rgb(222, 87, 0); font-weight: bold;">在op2调用之前得到返回</span>），那么在历史中，op1在op2之前</div><div>②<span style="color: rgb(50, 135, 18); font-weight: bold;">形式转化：这2个条件也可以被表述成下面3个条件</span></div><div>    【1】这个历史中的【调用事件和返回事件】可以被重排序生成一个顺序历史</div><div>    【2】<span style="color: rgb(50, 135, 18); font-weight: bold;">按照【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">对象的顺序定义</span><span style="color: rgb(50, 135, 18); font-weight: bold;">】，顺序历史是【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">正确</span><span style="color: rgb(50, 135, 18); font-weight: bold;">】的</span></div><div>    【3】如果在原始的历史中，一个返回事件在一个调用事件之前，<span style="color: rgb(222, 87, 0); font-weight: bold;">那么在顺序排序中，这个返回事件必须还是在前面</span>。</div><div><br/></div><div>217、【<span style="color: rgb(227, 0, 0); font-weight: bold;">线性一致性与顺序一致性的比较】</span></div><div>①<span style="color: rgb(222, 87, 0); font-weight: bold;">正确性条件</span>：</div><div>    与顺序一致性一样，线性一致性也是一种正确性条件</div><div>②<span style="color: rgb(222, 87, 0); font-weight: bold;">原子性</span>：</div><div>    <span style="color: rgb(50, 135, 18); font-weight: bold;">线性一致性也被称为【原子一致性】</span></div><div>③<span style="color: rgb(222, 87, 0); font-weight: bold;">实时性</span>：</div><div>    【1】<span style="color: rgb(50, 135, 18); font-weight: bold;">顺序一致性只要求保证【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">程序顺序】，而线性一致性要求保持【偏序关系】</span></div><div>    【2】保持偏序关系，给线性一致性赋予了<span style="color: rgb(222, 87, 0); font-weight: bold;">顺序一致性所【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">不具有</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】的一个特性，那就是【实时性】</span></div><div>    【3】<span style="color: rgb(227, 0, 0); font-weight: bold;">顺序一致性允许【陈旧读】，而线性一致性不允许，因为要保持【</span><span style="color: rgb(227, 0, 0); font-weight: bold;">偏序关系</span><span style="color: rgb(227, 0, 0); font-weight: bold;">】。</span></div><div><br/></div><div>218、①<span style="color: rgb(50, 135, 18); font-weight: bold;">强一致性</span>：在更新完成后，所有后续的访问都会读取到更新的值</div><div>②<span style="color: rgb(227, 0, 0); font-weight: bold;">【线性一致性】符合【强一致性】，在线性一致性下不会读取到旧数据，而是会读取到最新的数据。</span></div><div>③形式代换-线性一致性：</div><div>    如果操作B在操作A完成之后才开始，那么操作B一定能看到与操作A完成时【相同的系统状态】，或者看到更新的系统状态。</div><div><br/></div><div>区别【线性一致性与顺序一致性】</div><div><a href="https://www.dazhuanlan.com/if2521/topics/1602229">https://www.dazhuanlan.com/if2521/topics/1602229</a></div><div>①顺序一致性应用于<span style="color: rgb(222, 87, 0); font-weight: bold;">内存模型</span>，在内存模型领域中可以说是最强的一致性了。 </div><div>②内存模型实现线性一致性没有意义。当然因为顺序一致性对程序优化的约束，<span style="color: rgb(222, 87, 0); font-weight: bold;">现代计算机连【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">顺序一致性</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】都不保证</span>。</div><div>③线性一致性是一种捕获所有进程所有操作的<span style="color: rgb(50, 135, 18); font-weight: bold;">实际发生时间</span>先后顺序的一致性。</div><div>熟悉 Lamport 分布式时钟那篇论文的很快就会想到，那个全局逻辑时钟实际上就是提供了线性一致性。</div><div>④文章 <a href="https://zhuanlan.zhihu.com/p/42239873">https://zhuanlan.zhihu.com/p/42239873</a> 提供了一个线性一致性的应用场景。可以看到线性一致性应用在<span style="color: rgb(222, 87, 0); font-weight: bold;">分布式存储</span>中。</div><div>⑤<span style="color: rgb(222, 87, 0); font-weight: bold;">顺序一致性的局部性</span></div><div>根据论文 2，很容易看到当共享的数据结构是无顺序的字典的时候，顺序一致性也拥有局部性。 但是<span style="color: rgb(222, 87, 0); font-weight: bold;">当共享数据结构是队列的时候，局部性不能保持，</span></div><div>⑥顺序一致性的应用场景</div><div>待补充。但猜测顺序一致性作为一种<span style="color: rgb(50, 135, 18); font-weight: bold;">内存模型，现在已经没有了应用场景</span>。</div><div><br/></div><div><a href="https://blog.csdn.net/weixin_45506590/article/details/118498045">https://blog.csdn.net/weixin_45506590/article/details/118498045</a></div><div>①<span style="color: rgb(227, 0, 0); font-weight: bold;">如果说顺序一致性只保证</span><span style="color: rgb(227, 0, 0); font-weight: bold;">【单节点】事件先后顺序</span><span style="color: rgb(227, 0, 0); font-weight: bold;">的话，线性一致性还保证</span><span style="color: rgb(227, 0, 0); font-weight: bold;">【节点间】的事件先后顺序</span><span style="color: rgb(227, 0, 0); font-weight: bold;">。</span></div><div><br/></div><div>219、zookeeper的一致性分析</div><div>①<span style="color: rgb(222, 87, 0); font-weight: bold;">线性写入：线性一致性</span></div><div>②陈旧读</div><div>③<span style="color: rgb(50, 135, 18); font-weight: bold;">在follower上读：满足顺序一致性</span></div><div>④在follower读和写：</div><div>    【1】如果没有【写入等待：下一条中的操作】，则不符合</div><div>    【2】follower要确定【这次转发的写入】已经通过Zab算法复制到本地，然后才会给客户端返回成功。</div><div>                <span style="color: rgb(222, 87, 0); font-weight: bold;">这种写入等待，使zookeeper达到顺序一致性</span></div><div>⑤<span style="color: rgb(227, 0, 0); font-weight: bold;">Zab算法是不能保证【顺序一致性】的，还要控制好【</span><span style="color: rgb(227, 0, 0); font-weight: bold;">读操作的流程</span><span style="color: rgb(227, 0, 0); font-weight: bold;">】，才能让zookeeper整体【读+写】达到顺序一致性</span></div><div><br/></div><div>221、zookeeper的顺序一致性的作用</div><div>①<span style="font-size: unset; color: unset; font-family: unset;">zookeeper实现分布式锁</span></div><div>【1】基本思想：每个客户端都创建一个znode，所有的znode形成一个单调有序的队列，而排在队列最前面的客户端获得锁。</div><div>【2】思想成立的核心：<span style="color: rgb(222, 87, 0); font-weight: bold;">即使有多个客户端同时创建znode</span>，zookeeper仍然能有下面2个保证</div><div>            <span style="color: rgb(50, 135, 18); font-weight: bold;">（1）形成单调有序的队列</span></div><div><span style="color: rgb(50, 135, 18); font-weight: bold;">            （2）所有的客户端都会看到队列的同一个视图</span></div><div>【3】<span style="color: rgb(227, 0, 0); font-weight: bold;">zookeeper的顺序一致性，保证zookeeper具有正确的并发行为</span>，也就是保证zookeeper可以作为协调服务来使用。</div><div><br/></div><div>222、①既然zookeeper实现顺序一致性就可以满足zookeeper作为协调服务的要求，那么为什么还要实现比顺序一致性更强的线性一致性呢？</div><div><span style="color: rgb(227, 0, 0); font-weight: bold;">因为虽然顺序一致性没有zookeeper所实现的一致性强，但顺序一致性反而是【不好实现的一种一致性】</span></div><div>②【描述1】zookeeper的【论文中】</div><div>    【1】<span style="color: rgb(50, 135, 18); font-weight: bold;">线性写</span>：所有对zookeeper进行更新的请求都是【<span style="color: rgb(222, 87, 0); font-weight: bold;">线性】的，而且保持【优先顺序】</span></div><div>    【2】<span style="color: rgb(50, 135, 18); font-weight: bold;">FIFO客户端顺序</span>：某个客户端的所有请求，都是【<span style="color: rgb(222, 87, 0); font-weight: bold;">按照它们被发送的顺序</span>】实行的</div><div>③【描述2】zookeeper的<span style="color: rgb(227, 0, 0); font-weight: bold;">【社区文档】没有采用【论文中的描述】</span></div><div>    【1】顺序一致性：一个客户端的更新会按照它们被发送的顺序应用</div><div>    【2】原子性：更新要么成功，要么失败，<span style="color: rgb(222, 87, 0); font-weight: bold;">没有部分生效</span></div><div>    【3】及时性：<span style="color: rgb(50, 135, 18); font-weight: bold;">客户端对系统的视图保证在某一时间范围（在10秒的数量级）内侍最新的。【？？？】</span></div><div>                    系统的变更，要么在这个时间范围内会被客户端看到，要么客户端会检测到服务宕机。</div><div>④【描述3】概括了协调服务的一致性</div><div>    <span style="color: rgb(227, 0, 0); font-weight: bold;">协调服务的典型语义是：</span></div><div><span style="color: rgb(227, 0, 0); font-weight: bold;">    【1】原子更新（线性更新）</span></div><div><span style="color: rgb(227, 0, 0); font-weight: bold;">    【2】顺序一致性读</span></div><div><br/></div><div><br/></div><div>225、①CAP</div><div>【1】C：一致性consistency</div><div>【2】A：可用性available</div><div>【3】P：分区容忍性partition-tolerance</div><div>②<span style="color: rgb(222, 87, 0); font-weight: bold;">P必须有，分布式系统必须面对丢失信息这个问题</span></div><div><br/></div><div>227、①<span style="color: rgb(50, 135, 18); font-weight: bold;">CAP-Availability</span>：CAP定理中的可用性</div><div>    【1】<span style="color: rgb(227, 0, 0); font-weight: bold;">严格</span><span style="color: rgb(227, 0, 0); font-weight: bold;">：也叫</span><span style="color: rgb(227, 0, 0); font-weight: bold;">完全可用性</span>，严格在于要求每个请求都必须有响应，只要有一个请求没有响应，就不满足可用性的定义。</div><div>    【2】<span style="color: rgb(50, 135, 18); font-weight: bold;">非常弱</span>：<span style="color: rgb(222, 87, 0); font-weight: bold;">没有约束在多长时间</span>内给出响应，只要最终给出响应就可以。</div><div><br/></div><div>228、①HA：指通过副本方式形成一个主备系统，当出现【节点宕机，或网络分区】时，数据库服务仍然可用。</div><div>节点宕机+有副本能提供服务，这也达不到CAP-Availability</div><div>②zookeeper是一个具有HA的系统</div><div>③99.99%，也不满足CAP-Availability</div><div><br/></div><div>229、①论文中说明一个系统可以同时具有2个属性</div><div><span style="color: rgb(222, 87, 0); font-weight: bold;">①但这种表述并不等于说，放弃了一个属性，就一定会具有另外2个属性【芝士味变强留出了一些空间】</span></div><div>②不该轻易放弃任何一个属性：</div><div>    因为CAP不是一个二分法的方法论，放弃一个属性，不能将系统推向到另外一段</div><div><br/></div><div>230、①弱CAP原则</div><div>【1】一致性：不仅仅<span style="color: rgb(50, 135, 18); font-weight: bold;">是线性一致性</span>，也可以【<span style="color: rgb(222, 87, 0); font-weight: bold;">比线性一致性更弱的一致性模型</span>】</div><div>【2】可用性：不仅仅是CAP定理中的<span style="color: rgb(50, 135, 18); font-weight: bold;">CAP-Availability这种完全可用性</span>，<span style="color: rgb(222, 87, 0); font-weight: bold;">也可以是zookeeper这种比完全可用性更弱的一种可用性</span></div><div><br/></div><div><br/></div><div>231、①<span style="color: rgb(227, 0, 0); font-weight: bold;">CAP定理为NoSQL运动的落地，提供了有力的理论支撑</span></div><div>②同样身为<span style="color: rgb(222, 87, 0); font-weight: bold;">宽表数据库</span>的Dynamo和BigTable</div><div>    【1】Dynamo：选择了可用性</div><div>    【2】BigTable：选择了一致性</div><div><br/></div><div>232、①<span style="color: rgb(50, 135, 18); font-weight: bold;">在CAP-Availability的条件下，系统不但不能拥有【线性一致性】，而且实际上很多种【一致性模型】，系统也不可能拥有。</span></div><div>②<b><font style="color: rgb(227, 0, 0);">HAT【？？？】</font></b></div><div><br/></div><div>234、①【1】架构设计上的可用性</div><div><span>    </span><span>    </span><span>    【2】我们实际能感受到的系统的可能性</span><br/></div><div>②Mysql的日常使用中，一般会使用默认的RR级别，<b><font style="color: rgb(222, 87, 0);">RR级别不属于CAP-Availability，但一般公司的DBA都能让MySQL保持不错的SLA</font></b></div><div><b><font color="#E30000">③按照笔者的经验，【某台机器出现故障】所引起的系统不可用的概率，要小于由于【升级、错误的机器配置、错误的网络配置】所引起的系统不可用的概率</font></b></div><div>④<b><font style="color: rgb(50, 135, 18);">HAT是一种更宽泛的CAP</font></b></div><div>⑤无论是CAP还是HAT，都在讲分布式系统中最重要的一个问题，那就是权衡（tradeoff）</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div>
<hr>
<a name="34935"/>

<div>
<span><div>0、相关资料：</div><div>    ①P200：在《Distributed Systems：Principles and Paradigms》中，作者稍微修改了Lamport的定义</div><div>1、<span style="font-size: unset; color: unset; font-family: unset;">重点：192、【203、207】、【206、207】</span></div><div>2、问题：189、192</div><div>3、原文错误：205、</div><div><br/></div><div>【<span style="font-size: 12pt; color: rgb(50, 135, 18); font-weight: bold;">P184</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">-第13章：事务一致性与隔离级别</span>】</div><div>【<span style="font-size: 12pt; color: rgb(50, 135, 18); font-weight: bold;">P193</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">-第14章：顺序一致性</span>】</div><div><br/></div><div><br/></div><div><br/></div><div>184、①ACID</div><div>【1】原子性</div><div>【2】一致性：两个账户的总额不变</div><div>【3】隔离性：<span style="color: rgb(222, 87, 0); font-weight: bold;">数据库的事务往往是【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">并发执行</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】的，隔离性用来定义并发控制的程度</span></div><div>【4】持久性：存入硬盘</div><div><br/></div><div>185、<span style="color: rgb(222, 87, 0); font-weight: bold;">ANSI异常</span></div><div>①脏读：回滚了</div><div>②不可重复读：其他事务commit了新的值（同一个数据）</div><div>③幻读：其他事务commit了新的值（同一个表）</div><div><br/></div><div>186、<span style="color: rgb(222, 87, 0); font-weight: bold;">ANSI隔离级别</span></div><div>①读未提交</div><div>②读已提交：避免了脏读</div><div>③可重复读：避免了脏读、不可重复读</div><div>④可串行化：避免了脏读、不可重复读、幻读</div><div><br/></div><div>187、【例子】</div><div><br/></div><div>188、①脏写：如果事务1回滚了，<span style="color: rgb(222, 87, 0); font-weight: bold;">则不知道应该回滚到哪里</span></div><div>②锁机制</div><div>    【1】范围（scope）：数据项锁，<span style="color: rgb(50, 135, 18); font-weight: bold;">谓词锁（对条件加锁，比如where a==1）</span></div><div>    【2】模式：读锁，写锁</div><div>    【3】持久：</div><div>            （<span style="color: rgb(50, 135, 18); font-weight: bold;">1）</span><span style="color: rgb(50, 135, 18); font-weight: bold;">长周期锁：保持到事务结束</span></div><div><span style="color: rgb(50, 135, 18); font-weight: bold;">            （2）短周期锁：只在操作执行时加锁</span></div><div><br/></div><div>189、①wl加写锁，ul：解锁</div><div>②写入某个数据：短周期+数据项+写锁</div><div>③<span style="color: rgb(222, 87, 0); font-weight: bold;">防止脏写：长周期+数据项+写锁</span>——好像没啥区别？就是加锁和解锁</div><div>④<span style="color: rgb(222, 87, 0); font-weight: bold;">防止脏读：短周期+数据项+读锁</span>——</div><div>⑤防止不可重复读：长周期锁+数据项+读锁</div><div>⑥防止幻读：长周期+<span style="color: rgb(50, 135, 18); font-weight: bold;">谓词项</span>+读锁</div><div><br/></div><div>190、①MVCC：</div><div>    【1】多个版本+快照读取</div><div>    【2】避免了【脏读、不可重复读、幻读】</div><div>    【3】<span style="color: rgb(222, 87, 0); font-weight: bold;">没有达到serializable隔离级别——</span></div><div><span style="color: rgb(222, 87, 0); font-weight: bold;">            【</span><span style="color: rgb(227, 0, 0); font-weight: bold;">SI隔离级别</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】</span></div><div>            （1）<span style="color: rgb(50, 135, 18); font-weight: bold;">丢失更新</span>：累积操作失去效果。<span style="color: rgb(50, 135, 18); font-weight: bold;">两个线程，都读取了a=1，执行a=a+1</span></div><div>            （2）<span style="color: rgb(50, 135, 18); font-weight: bold;">写偏斜</span>：失去数据约束。a&gt;0，a=30，线程1修改了a=a-20,线程2修改了a=a-20，分别来说都符合数据约束，但总体不符合a&gt;0了</div><div><br/></div><div>192、SSI隔离级别</div><div>①postgreSQL早期只支持SI隔离级别，<span style="color: rgb(222, 87, 0); font-weight: bold;">后来研究如何在SI隔离级别的基础上，避免脏写和写偏斜</span></div><div>②<span style="color: rgb(50, 135, 18); font-weight: bold;">SSI：serializable Snapshot Isolation</span>，命名它的最高隔离级别</div><div>③本质上仍然是serializable隔离级别，<span style="color: rgb(222, 87, 0); font-weight: bold;">只是SSI是完全基于MVCC、镜像等技术实现的serializable隔离级别</span></div><div>④CockRoachDB：也是完全基于MVCC、镜像技术实现的，<span style="color: rgb(227, 0, 0); font-weight: bold;">没有采用任何锁技术</span></div><div>⑤MYSQL，Spanner：采用了MVCC和镜像技术，<span style="color: rgb(227, 0, 0); font-weight: bold;">但也用了锁技术</span></div><div><br/></div><div><br/></div><div><br/></div><div>【<span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(50, 135, 18); font-weight: bold;">P193</span></span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">-第14章：顺序一致性</span>】</div><div><br/></div><div>193、①<span style="color: rgb(222, 87, 0); font-weight: bold;">对待【陌生概念】，用【自己已知的知识体系】去理解这个陌生概念</span></div><div>②<span style="color: rgb(50, 135, 18); font-weight: bold;">这里强烈推荐先放下之前的理解，按照本节的思路（也就是Lamport的思路）来理解顺序一致性</span></div><div><br/></div><div>194、①多机器+机器上的多线程</div><div>②顺序一致性：</div><div>“任何操作的结果都是一样的，就像所有的处理器以某种顺序执行了。“</div><div>“而且每个独立的处理器的操作，都会按照程序指定的顺序，出现在操作序列中”</div><div>②<span style="color: rgb(222, 87, 0); font-weight: bold;">作者感受：“Lamport一向的风格，严谨，但晦涩”</span></div><div><br/></div><div>195、①执行+结果</div><div><br/></div><div>196、①顺序执行（sequential order）：【没有重叠】地操作</div><div>②如果把两个处理器上的3个操作，<span style="color: rgb(222, 87, 0); font-weight: bold;">按照【顺序执行】，则有3！个，也就是6个结果（</span><span style="color: rgb(50, 135, 18); font-weight: bold;">同一处理器的操作也没有按顺序</span><span style="color: rgb(222, 87, 0); font-weight: bold;">）</span></div><div>③<span style="color: rgb(50, 135, 18); font-weight: bold;">序列</span>：排序产生的【结果】</div><div><br/></div><div>198、【<span style="color: rgb(227, 0, 0); font-weight: bold;">1、结果相同</span>】</div><div>①对于每一种可能的执行结果，都好像存在一种顺序排序，而产生一个序列</div><div><span style="color: rgb(222, 87, 0); font-weight: bold;">每种【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">可能的执行结果</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】，至少与【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">一个序列执行的结果</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】一样</span></div><div>②execution1=sos1 or sos2</div><div><span style="color: rgb(227, 0, 0); font-weight: bold;">注意：此处区分【</span><span style="color: rgb(227, 0, 0); font-weight: bold;">3种执行的结果</span><span style="color: rgb(227, 0, 0); font-weight: bold;">】+【顺序执行的6种序列的结果】</span></div><div><br/></div><div>199、【<span style="color: rgb(227, 0, 0); font-weight: bold;">2、程序顺序</span>】</div><div>①每个处理器上的操作，都会按照程序指定的顺序，出现在操作序列中</div><div>②<span style="color: rgb(50, 135, 18); font-weight: bold;">人话：同一个处理器，指令的执行顺序不变</span></div><div>③<span style="color: rgb(222, 87, 0); font-weight: bold;">如果一个多处理器计算机上，运行的所有程序的所有可能的执行</span>，都满足这个定义，那么这个多处理器计算机就是顺序一致性的。</div><div>④program可以用来说明各种程序，不管是操作系统内核，还是应用程序</div><div><br/></div><div>200、①<span style="color: rgb(222, 87, 0); font-weight: bold;">在《Distributed Systems：Principles and Paradigms》中，作者稍微修改了Lamport的定义：</span></div><div>【1】作者把<span style="color: rgb(50, 135, 18); font-weight: bold;">处理器（processor）换成了进程（process）</span></div><div>【2】并且加了在数据存储中（on the data store）这个限定。</div><div>②案例</div><div>    【1】分布式系统</div><div>    【2】多处理器计算机</div><div><br/></div><div>201、①zookeeper的所有实际执行都符合顺序一致性</div><div><br/></div><div>202、【<span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">顺序排序</span>】</div><div>①前面讲解了顺序一致性的正式定义，</div><div>    【1】<span style="color: rgb(222, 87, 0); font-weight: bold;">表面上看，这个定义有些在说废话，</span></div><div>    【2】<span style="color: rgb(50, 135, 18); font-weight: bold;">但实际上，顺序一致性的定义是非常【严苛】的</span></div><div>②实现顺序一致性：需要存在一定的<span style="color: rgb(222, 87, 0); font-weight: bold;">并发控制系统，也就是锁机</span><span style="color: rgb(222, 87, 0); font-weight: bold;">制</span>，<span style="color: rgb(50, 135, 18); font-weight: bold;">成本往往很高</span></div><div>③不管是多处理器计算机还是分布式系统，<span style="color: rgb(227, 0, 0); font-weight: bold;">【具体实现】</span><span style="color: rgb(227, 0, 0); font-weight: bold;">内部可以并发执行，但是【</span><span style="color: rgb(227, 0, 0); font-weight: bold;">结果</span><span style="color: rgb(227, 0, 0); font-weight: bold;">】要与顺序执行的结果相同</span></div><div><br/></div><div>203、</div><div>①顺序一致性 是【非常严苛】的。</div><div>多处理器计算机满足顺序一致性，【<span style="color: rgb(222, 87, 0); font-weight: bold;">多个程序在多个处理器上运行的效果</span>】，应等同于【<span style="color: rgb(50, 135, 18); font-weight: bold;">在一个处理器上顺序执行</span>所有操作的效果】</div><div>②如果这样的话，多核的威力基本就消失了。</div><div>    大大限制了编译器指令重排和高速缓存优化</div><div>③顺序一致性并没有规定多处理器计算机【<span style="color: rgb(222, 87, 0); font-weight: bold;">如何实现并发机制</span>】，但是要求这种并发机制，能够达到【顺序执行的效果】</div><div>④<span style="color: rgb(50, 135, 18); font-weight: bold;">到现在，【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">没有任何一个</span><span style="color: rgb(50, 135, 18); font-weight: bold;">】现实的多处理器计算机实现了【顺序一致性】。</span></div><div><span style="color: rgb(227, 0, 0); font-weight: bold;">那么，Lamport大神为什么提出这样一个不现实的概念呢？</span></div><div><br/></div><div>204、顺序一致性的其他描述：</div><div>    笔者选取的都是对顺序一致性的【正确描述】，<span style="color: rgb(50, 135, 18); font-weight: bold;">主要是想说明如何从【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">正式定义</span><span style="color: rgb(50, 135, 18); font-weight: bold;">】推导出【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">这些描述</span><span style="color: rgb(50, 135, 18); font-weight: bold;">】</span></div><div>①全局视角一致</div><div>②允许重排序【<span style="color: rgb(227, 0, 0); font-weight: bold;">P205的例子有问题</span>】</div><div><br/></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">【顺序一致性的作用】：并发条件+原子性</span></div><div>206、①并发条件：最多只有一个程序鞥能够进入<span style="color: rgb(50, 135, 18); font-weight: bold;">【critical session】——一种多线程synchronization机制，这个例子没有用到任何锁。</span></div><div><br/></div><div>207、①在Lamport的Paxos论文中，<span style="color: rgb(227, 0, 0); font-weight: bold;">有很多细节是一笔带过的</span>，给读者留下无尽的遐想</div><div>②顺序一致性，是程序正确执行的【并发条件（concurrency condition）】</div><div>    【1】<span style="color: rgb(222, 87, 0); font-weight: bold;">如果多处理器计算机是【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">顺序一致性</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】的，那么你写的</span><span style="color: rgb(50, 135, 18); font-weight: bold;">并发程序“天然就是正确的”</span>。</div><div>            <span style="font-weight: bold;">所以，为了保证 分布式系统的正确性，各种分布式系统纷纷满足顺序一致性。</span></div><div>            只要实现了顺序一致性，在各种并发场景下，分布式系统天然地就能正确执行</div><div>    【2】线性一致性：也是一种并发条件</div><div>③<span style="color: rgb(222, 87, 0); font-weight: bold;">很多实际的系统告诉我们，没有多少【并发优化的手段】可以用，实现顺序一致性就是【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">将所有的请求操作顺序执行</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】，系统中【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">没有并发操作</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】。</span></div><div><br/></div><div>207-209：【原子性】</div><div>①所有的操作需要有【原子性】</div><div>    【1】是必要条件，不是充分条件。</div><div>    【2】<span style="color: rgb(222, 87, 0); font-weight: bold;">操作不是原子操作，也可能满足顺序一致性。</span></div><div>②瞬间操作：可以被看作一种特例的原子操作。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div>
<hr>
<a name="34179"/>

<div>
<span><div>0、相关资料：</div><div>1、<span style="font-size: unset; color: unset; font-family: unset;">重点：155、162、166、177、【166+172：zxid明明包含epoch啊？】、180、181</span></div><div>【<span style="color: rgb(227, 0, 0); font-weight: bold;">其实能获得epoch，但是这里zxid只用来事务的“先后顺序的排序”，不对epoch做其他处理</span>】</div><div>2、问题：156、161、<span style="color: rgb(227, 0, 0); font-weight: bold;">162</span>、167、176、179（保证1）、182</div><div>3、原文错误：175</div><div><br/></div><div><br/></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-weight: bold; font-size: 12pt; color: rgb(227, 0, 0);">【</span><span style="font-weight: bold; font-size: 12pt; color: rgb(65, 173, 28);">P152：</span><span style="font-weight: bold; font-size: 12pt; color: rgb(227, 0, 0);">11章-日志复制算法Raft】</span></font></div><div><font style="font-size: 12pt;"><span style="font-weight: bold; font-size: 12pt; color: rgb(227, 0, 0);">【</span><span style="font-weight: bold; font-size: 12pt; color: rgb(65, 173, 28);">P163：</span><span style="font-weight: bold; font-size: 12pt; color: rgb(227, 0, 0);">12章-原子广播算法Zab】</span></font></div><div><br/></div><div><br/></div><div>153、①Raft采用RPC实现节点间的通信。</div><div>包括复制过程、选举过程、异常处理</div><div><br/></div><div>154、①leader收到大多数follower的回复后，将entry提交到状态机</div><div>②<span style="color: rgb(222, 87, 0); font-weight: bold;">更新follower中的</span>——已经commit的entry提交到状态机</div><div>【1】leader将下一个entry复制到所有follower的请求中，会携带【committed状态的entry的index】+【这次要添加的还没commit的entry】</div><div>【2】发送的心跳信息，也会携带committed状态的entry的index</div><div>③<span style="color: rgb(50, 135, 18); font-weight: bold;">即使【少数节点变慢+网络拥堵】，也不会导致这个过程变慢</span></div><div><br/></div><div>155、①<span style="color: rgb(222, 87, 0); font-weight: bold;">任期（term）解决的问题</span></div><div>【1】多个candidate冲突，需要重新选举。</div><div>用来区分新旧选举</div><div>【2】脑裂</div><div>②raft中，时间被分为很多个任期，<span style="color: rgb(50, 135, 18); font-weight: bold;">每个任期都从一次选举开始</span></div><div>【1】candidate获胜，则获得【这个任期】</div><div>【2】没有candidate获胜，进行【下一个任期】</div><div><span style="color: rgb(227, 0, 0); font-weight: bold;">（注意，此处为典型的叙述问题，抽象度太高，而缺乏具体例子）</span></div><div><br/></div><div>156、①解决多个candidate：随机超时（随机回退）</div><div><span style="color: rgb(227, 0, 0); font-weight: bold;">②活锁？？</span></div><div>③leader宕机恢复后，会发现大多数节点有更大的任期，退化为follower</div><div><br/></div><div>157、①<span style="color: rgb(222, 87, 0); font-weight: bold;">candidate：收到其他节点的请求，其任期与自己相同。</span></div><div>说明其他candidate已经在本轮选举中【获胜】，自己退化为follower</div><div>②</div><div><br/></div><div>159、<span style="color: rgb(227, 0, 0); font-weight: bold;">不一致异常的【具体案例】</span></div><div>①比leader少</div><div>②比leader多</div><div>③<span style="color: rgb(222, 87, 0); font-weight: bold;">比leader多一部分，又比leader少一部分</span></div><div><br/></div><div>160、①follower与leader保持一致，<span style="color: rgb(222, 87, 0); font-weight: bold;">不一致的要丢弃，替换为leader相应的部分</span></div><div>②Raft策略：新的leader上所有<span style="color: rgb(222, 87, 0); font-weight: bold;">未提交的entry</span>保留，其他节点上<span style="color: rgb(222, 87, 0); font-weight: bold;">未提交的entry</span>丢弃</div><div>③raft一致性检查</div><div>    【1】leader发送AppendEntriesRPC时，会包含【<span style="color: rgb(50, 135, 18); font-weight: bold;">新entry+新entry前面一个entry的index和任期</span>】</div><div>    【2】<span style="font-weight: bold;">如果follower拒绝，则leader不断回退</span></div><div>④不提交旧的leader的entry</div><div>    【1】前面说，leader会保留未提交的entry。</div><div><span style="color: rgb(222, 87, 0); font-weight: bold;">但新的leader不会提交这些未提交的entry，而是继续追加新entry。</span></div><div><span style="color: rgb(50, 135, 18); font-weight: bold;">当新entry达到提交状态，则会自动提交前面未提交的entry【raft的一致性检查】</span></div><div><br/></div><div>161、①<span style="color: rgb(227, 0, 0); font-weight: bold;">例子里的，虚线里的数字是什么意思？？</span></div><div><span style="color: rgb(50, 135, 18); font-weight: bold;">好像是待写入的数据</span></div><div><br/></div><div>162、</div><div>①<span style="color: rgb(227, 0, 0); font-weight: bold;">新的leader对未提交的entry进行提交操作，会导致丢失更新（丢失已commit的数据）</span></div><div><span style="color: rgb(166, 0, 196); font-weight: bold;">关键点@@：节点4为什么能成为leader</span></div><div>②未提交的数据被删除</div><div>③未提交的数据，随着新entry被提交。</div><div><img src="《分布式算法与一致性》_files/Image.png" type="image/png" data-filename="Image.png" width="502"/></div><div><br/></div><div>163、①<span style="color: rgb(50, 135, 18); font-weight: bold;">设计的Zab算法</span></div><div>②<span style="color: rgb(222, 87, 0); font-weight: bold;">Zab Pre 1.0算法（有错误的版本）</span></div><div>③<span style="color: rgb(50, 135, 18); font-weight: bold;">Zab 1.0（与设计的Zab算法基本相同，只是细节优化）</span></div><div><br/></div><div>164、①设计的Zab算法和Zab1.0：<span style="font-weight: bold;">选举、发现、【</span><span style="color: rgb(227, 0, 0); font-weight: bold;">同步</span><span style="font-weight: bold;">】、广播：election，discovery，synchronization，broadcast</span></div><div>Zab pre1.0实现：选举、发现、广播</div><div>②Zab算法是一种原子广播算法。</div><div><span style="color: rgb(222, 87, 0); font-weight: bold;">与paxos算法实现的【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">原子广播</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】不同的是，在Zab算法中要广播的值为【消息（message）】</span></div><div><br/></div><div>165、①zookeeper采用【<span style="color: rgb(222, 87, 0); font-weight: bold;">首要备份模式</span>】：leader+follower</div><div>只有【首要进程】才能接收客户端请求，<span style="color: rgb(50, 135, 18); font-weight: bold;">并把客户端的请求转换为【事务】</span></div><div>②区分前后两个首要进程：<span style="color: rgb(222, 87, 0); font-weight: bold;">纪元epoch</span></div><div>③<span style="color: rgb(50, 135, 18); font-weight: bold;">zookeeper的首要进程与Zab算法的leader</span>，被刻意地由同一个进程来担任，这样就可以共用相同的选举功能。</div><div>并且把首要进程到leader的<span style="color: rgb(222, 87, 0); font-weight: bold;">广播接口调用，变为本地调用 。</span></div><div><br/></div><div>166、①<span style="color: rgb(227, 0, 0); font-weight: bold;">本书架构模式</span></div><div>【1】<span style="color: rgb(227, 0, 0); font-weight: bold;">首要备份模式</span>：<span style="color: rgb(50, 135, 18); font-weight: bold;">zookeeper和Zab算法</span></div><div>主从，<span style="color: rgb(222, 87, 0); font-weight: bold;">从不工作</span>。从不处理客户端请求，但会随时准备在primary出故障时，顶替它的工作</div><div>【2】<span style="color: rgb(227, 0, 0); font-weight: bold;">领导跟随模式</span>：<span style="color: rgb(50, 135, 18); font-weight: bold;">zookeeper和Zab算法</span></div><div>主从，<span style="color: rgb(222, 87, 0); font-weight: bold;">从工作</span>，完全模仿leader的工作，leader处理一个请求，folllower也会复制leader处理这个请求的结果。</div><div>【3】<span style="color: rgb(227, 0, 0); font-weight: bold;">主仆模式</span>：<span style="color: rgb(50, 135, 18); font-weight: bold;">GFS、BigTable、Spanner</span></div><div>master只负责给slave分配任务，，slave负责实际工作。</div><div>②<span style="color: rgb(222, 87, 0); font-weight: bold;">zxid</span>：<span style="font-weight: bold;">由于【</span><span style="font-weight: bold;">客户端请求</span><span style="font-weight: bold;">】是由【</span><span style="font-weight: bold;">唯一的首要进程</span><span style="font-weight: bold;">】处理的</span>，因此首要进程可以为每个事务生成【一个编号】</div><div><span style="color: rgb(50, 135, 18); font-weight: bold;">[e,c]：epoch，计数器counter</span></div><div>③<span style="color: rgb(222, 87, 0); font-weight: bold;">事务</span>：&lt;z , v&gt;——z是zxid，v是事务的内容</div><div><br/></div><div>167、①发起【一个提议】：<span style="color: rgb(227, 0, 0); font-weight: bold;">事务和提议的区别？提议有epoch</span></div><div>②持久化到历史（history）中，提议处于已接受（accepted）、已提议（proposed）</div><div>③commit请求，在history中标记这个提议为已提交（committed）</div><div>④<span style="color: rgb(222, 87, 0); font-weight: bold;">168、应用这个事务。</span></div><div>相当于m=ADeliver()这个动作，在zookeeper中就是在数据库中应用这个事务。</div><div><span style="color: rgb(222, 87, 0); font-weight: bold;">也就是【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">原子广播</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】的投递（deliver）操作，在完成投递操作后，这个消息（也就是事务）处于已投递（delivered）状态</span></div><div><br/></div><div>168、①代码实现</div><div>【1】在leader内部，也像对待follower一样，进行【网络通信】，进行【leader和follower的过程】</div><div>【2】<span style="color: rgb(222, 87, 0); font-weight: bold;">改进：leader内部不进行网络通信</span></div><div><br/></div><div>169、①发送缓冲队列，接收缓冲队列。</div><div>②如果请求在网络上丢失，【<span style="color: rgb(50, 135, 18); font-weight: bold;">消息通道</span>】要负责重传丢失的请求，并且保证请求有序地传输</div><div>③<span style="color: rgb(222, 87, 0); font-weight: bold;">按照zxid的顺序</span>进行写入和取出</div><div>④<span style="color: rgb(50, 135, 18); font-weight: bold;">Zab算法具有处理，由于故障导致缓存的消息丢失的能力。</span></div><div><br/></div><div>170、①<span style="color: rgb(222, 87, 0); font-weight: bold;">follower的处理速度变慢</span>，请求会被暂存在缓存中。</div><div><span style="color: rgb(222, 87, 0); font-weight: bold;">当follower的处理速度恢复后</span>，则会加快处理缓存中的请求</div><div>②<span style="color: rgb(50, 135, 18); font-weight: bold;">如果leader收到【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">大多数follower的ACK</span><span style="color: rgb(50, 135, 18); font-weight: bold;">】，就会完成这次广播，所以少数follower的处理速度变慢。</span></div><div>③局部特点：提交操作</div><div>【1】数据库：<span style="color: rgb(222, 87, 0); font-weight: bold;">执行了【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">提交操作</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】，才会变成【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">已提交状态</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】</span></div><div>【2】Zab算法中，<span style="color: rgb(222, 87, 0); font-weight: bold;">提议先处【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">于已提交状态</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】，然后再进行【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">提交操作</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】。</span></div><div>④不同节点知道一个提议【<span style="font-weight: bold;">处于已提交状态的时间</span>】是不同的，【<span style="font-weight: bold;">执行提交操作的时间</span>】也是不同的。</div><div><br/></div><div>171、①follower故障：重启后数据同步</div><div>leader故障：重新选举</div><div><span style="color: rgb(222, 87, 0); font-weight: bold;">②保证1：如果一个【提议】在某个副本上已经被投递，那个一定要保证【这个提议】在其他副本上也被投递。</span></div><div>③将proposal请求简写为P，将commit请求简写成C</div><div>④<span style="color: rgb(50, 135, 18); font-weight: bold;">有具体例子</span></div><div><br/></div><div>172、<span style="color: rgb(222, 87, 0); font-weight: bold;">①保证2：如果commit了proposal【1,1】，那</span><span style="color: rgb(50, 135, 18); font-weight: bold;">重启后</span><span style="color: rgb(222, 87, 0); font-weight: bold;">的leader的【0,3】应该被丢弃</span></div><div>②原因：<span style="color: rgb(222, 87, 0); font-weight: bold;">按照zxid排列的提议序列</span>中，提交操作应该<span style="color: rgb(50, 135, 18); font-weight: bold;">跳过</span>proposal【0,3】</div><div>③<span style="color: rgb(227, 0, 0); font-weight: bold;">一个提议：事务&lt;z , v&gt;和epoch两部分。</span></div><div><span style="color: rgb(227, 0, 0); font-weight: bold;">&lt;e,&lt;z,v&gt;&gt;</span></div><div><br/></div><div>173、①history：所有接受的提议</div><div><span style="font-weight: bold;">lastZxid：history中所有提议最大的zxid</span></div><div><span style="color: rgb(222, 87, 0); font-weight: bold;">acceptedEpoch：接受的epoch</span><span style="color: rgb(50, 135, 18);">。</span><span style="color: rgb(50, 135, 18); font-weight: bold;">是接受的最后一个NewEpoch请求中的epoch</span>，NewEpoch是<span style="color: rgb(222, 87, 0); font-weight: bold;">discovery阶段</span>的一个请求。</div><div><span style="color: rgb(222, 87, 0); font-weight: bold;">currentEpoch：当前的epoch</span>。<span style="color: rgb(50, 135, 18); font-weight: bold;">是接受的最后一个NewLeader请求中的epoch</span>，NewLeader是<span style="color: rgb(222, 87, 0); font-weight: bold;">synchronization阶段</span>的一个请求。</div><div><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">②【</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">选举阶段</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">】：</span></div><div>【1】所选出的节点可以不是活着的节点，<span style="color: rgb(222, 87, 0); font-weight: bold;">也可以不是大多数认同的节点（即可以有多个节点被选成leader），设计的Zab算法保证不会出错。</span></div><div>【2】如果出现上面这些情况，<span style="color: rgb(50, 135, 18); font-weight: bold;">Zab算法会判断为异常，并且退回到election阶段，重新进行选举</span></div><div>③设计的Zab算法，<span style="color: rgb(50, 135, 18); font-weight: bold;">并未给出具体的选举算法。</span></div><div><span style="color: rgb(50, 135, 18); font-weight: bold;">（ 但会纠错。）</span></div><div>④选举阶段：<span style="color: rgb(222, 87, 0); font-weight: bold;">预主（prospective leader）</span></div><div>进行完【发现+同步】后，满足要求，则为<span style="color: rgb(222, 87, 0); font-weight: bold;">认定主（established leader）</span></div><div><br/></div><div>174、<span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">【</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">发现阶段</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-weight: bold;">discovery</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">】：NewEpoch(e)</span></div><div>①<span style="color: rgb(222, 87, 0); font-weight: bold;">follower发送</span>cEpoch[F.acceptedEpoch]请求给prospective leader</div><div>②prospective leader<span style="color: rgb(222, 87, 0); font-weight: bold;">从大多数follower</span>收到CEpoch请求，<span style="color: rgb(50, 135, 18); font-weight: bold;">这些follower形成一个集合，称为Q</span></div><div>prospective leader生成一个新的epoch，<span style="color: rgb(222, 87, 0); font-weight: bold;">这个epoch比收到的所有cEpoch请求中的epoch都大</span>。</div><div>prospective leader<span style="color: rgb(222, 87, 0); font-weight: bold;">发送NewLeader（epoch）给集合Q</span>中的每个follower</div><div>（epoch简化为e）</div><div>③follower收到NewLeader（e）请求</div><div>【1】如果e&gt;F.acceptedEpoch,则F.acceptrdEpoch=e，回复ack-e</div><div>【2】<span style="color: rgb(50, 135, 18); font-weight: bold;">若e&lt;F.acceptedEpoch，则回到election阶段</span></div><div>④leader收到<span style="color: rgb(222, 87, 0); font-weight: bold;">集合Q中每个follower</span>的ack-e回复后</div><div>根据F.currentEpoch和F.lastZxid，<span style="color: rgb(50, 135, 18); font-weight: bold;">选择最大的follower，将这个follower的history持久化保存为自己的历史</span></div><div>⑤注意：这里只修改了acceptedEpoch，没有修改currentEpoch</div><div><br/></div><div>175、<span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">【同步阶段</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-weight: bold;">synchronization</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">】：NewLeader(e,L.history)</span></div><div>①leader向集合Q中的所有follower，发送NewLeader（e,L.history）</div><div>②follower收到NewLeader（e,L.history）</div><div>【1】e！=F.acceptedEpoch，则回到election阶段</div><div>【2】e==F.acceptedEpoch</div><div><span style="color: rgb(50, 135, 18); font-weight: bold;">F.currentEpoch=e</span>，<span style="color: rgb(222, 87, 0); font-weight: bold;">将L.history中的提议，修改epoch组成新提议，存入自己的F.history</span></div><div>③leader收到【<span style="color: rgb(50, 135, 18); font-weight: bold;">大多数</span>】follower节点的ack后，给【<span style="color: rgb(50, 135, 18); font-weight: bold;">所有的】</span>follower发送commit请求</div><div>④follower收到commit后，<span style="color: rgb(222, 87, 0); font-weight: bold;">为F.history中的每个提议调用ADeliver（</span><span style="color: rgb(222, 87, 0); font-weight: bold;">）</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">【广播阶段</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-weight: bold;">broadcast</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">】：proposal</span></div><div>①【1】<span style="color: rgb(222, 87, 0); font-weight: bold;">leader增加zxid</span>，给集合Q中所有follower发送proposal请求。</div><div>【2】follower收到proposal请求后，将提议追加到history，回复ack</div><div>【<span style="color: rgb(227, 0, 0); font-weight: bold;">原文中有错误，写成了“给提议追加history”</span>】</div><div>【3】leader收到大多数follower的ack后，，发送commit</div><div>【4】follower收到commit，提交提议</div><div>②<span style="color: rgb(227, 0, 0);">【</span><span style="color: rgb(227, 0, 0); font-weight: bold;">当有新的follower加入集群时</span><span style="color: rgb(227, 0, 0);">】+【</span><span style="color: rgb(227, 0, 0); font-weight: bold;">follower宕机+恢复后加入集群P171</span><span style="color: rgb(227, 0, 0);">】</span><span style="color: rgb(50, 135, 18); font-weight: bold;">，follower会执行discovery阶段、synchronization阶段、broadcast阶段的过程</span>。</div><div><span style="color: rgb(222, 87, 0); font-weight: bold;">位于broadcast阶段的leader会执行下面的过程</span></div><div>【1】leader收到cEpoch请求后，发送NewEpoch和NewLeader给follower</div><div>【2】leader收到follower的ack后，给follower发送commit</div><div><br/></div><div>176、①将【全量传输】变为【增量传输】</div><div><span style="color: rgb(222, 87, 0); font-weight: bold;">②处理leader故障【P171】</span></div><div>【1】在synchronization阶段，leader收到大多数follower的ACK后，提交history中的所有提议。</div><div>follower在收到UpToDate消息后，会提交history中的所有提议。</div><div>【2】<span style="color: rgb(50, 135, 18); font-weight: bold;">所以【未被选中的history】中的【所有未提交的提议】都会被删除，【被选中的history】中的所有已提交的提议，会在所有节点上【再次被投递】。</span></div><div><span style="color: rgb(227, 0, 0); font-weight: bold;">【3】但是这里需要注意 ，【已提交的提议】可能会被【重复投递】。</span></div><div><br/></div><div>177、【<span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">Zab Pre1.0算法</span>】+【<span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">leader election阶段：</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-weight: bold;">fast leader election</span>】</div><div>①<span style="color: rgb(227, 0, 0); font-weight: bold;">与设计的Zab算法不同，Zab Pre1.0算法中的提议，只包含事务，并不包含epoch。</span></div><div><span style="color: rgb(227, 0, 0); font-weight: bold;">【提议+事务】没有区别。</span></div><div>从而也导致了BUG存在</div><div>②lastZxid：history中<span style="color: rgb(222, 87, 0); font-weight: bold;">最后一个提议</span>的zxid</div><div>lastCommittedZxid：history中<span style="color: rgb(222, 87, 0); font-weight: bold;">最后一个已提交的提议</span>的zxid</div><div>③<span style="color: rgb(50, 135, 18); font-weight: bold;">与设计的Zab算法不同，</span></div><div>【1<span style="color: rgb(227, 0, 0);">】</span><span style="color: rgb(227, 0, 0); font-weight: bold;">选举有一个额外条件：选举zxid最大的节点作为leader</span></div><div>【2】这个条件是ZabPre1.0算法的<span style="color: rgb(50, 135, 18); font-weight: bold;">正确性条件，而不是效率条件。</span></div><div><br/></div><div>177+178、【<span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">recovery阶段</span>】</div><div>①recovery阶段：<span style="font-weight: bold;">是epoch和follower同步的阶段</span></div><div>【1】<span style="color: rgb(222, 87, 0); font-weight: bold;">leader将L.lastZxid中的epoch加1</span>，开始接受follower的连接</div><div>【2】<span style="color: rgb(222, 87, 0); font-weight: bold;">follower给leader发送Follower（F.lastZxid）</span></div><div>【3】leader处理<span style="color: rgb(50, 135, 18); font-weight: bold;">每一个</span>follower连接</div><div>    （1）leader发送NewLeader（L.lastZxid）</div><div>    （2）leader建立一个临时的消息队列</div><div>    （3）执行下面的操作</div><div>            1、follower落后太多，<span style="color: rgb(227, 0, 0); font-weight: bold;">SNAP请求</span>放入队列</div><div>            2、follower包含leader没有的提议，将<span style="color: rgb(227, 0, 0); font-weight: bold;">TRUN（L.lastCommittedZxid）</span>请求放入队列</div><div>            3、follower缺少leader的提议，将<span style="color: rgb(227, 0, 0); font-weight: bold;">DIFF（proposals）</span>请求放入队列。【<span style="color: rgb(222, 87, 0); font-weight: bold;">proposals表示所有zxid大于L.lastCommittedZxid</span>】</div><div>    （4）leader将<span style="color: rgb(227, 0, 0); font-weight: bold;">UPTODATE请求</span>放入队列。</div><div>【4】follower根据【<span style="color: rgb(222, 87, 0); font-weight: bold;">队列中的请求</span>】进行处理</div><div>    （1）收到NewLeader请求，如果L.lastZxid.epoch&lt;F.lastZxid.epoch,则回到election阶段。</div><div>    （2）执行下面的操作</div><div>            1、SNAP请求：提交SNAP中的所有数据</div><div>            2、TRUN请求，删除从L.history.lastCommittedZxid到F.lastZxid的所有提议</div><div>            3、DIFF请求，则接受消息中携带的所有提议，<span style="color: rgb(222, 87, 0); font-weight: bold;">并且提交</span></div><div>    （3）一旦follower收到UPTODATE请求，follower就回复ACK（F.lastZxid）</div><div>【5】leader从大多数follower收到ACK，<span style="color: rgb(50, 135, 18); font-weight: bold;">则表明leader已经拿到值为e的epoch的领导权。</span></div><div><br/></div><div>178+179：【对照图P171】</div><div>①保证1：处理leader故障。</div><div>先TRUNC（1）丢弃不一致的，再DIFF（proposal2）增加缺少的。</div><div><br/></div><div>179、【处理保证1】</div><div>①在这个例子中，<span style="font-weight: bold;">server3删除的proposal2和新收到的proposal2其实没有区别</span>。</div><div>（<span style="color: rgb(222, 87, 0); font-weight: bold;">因为没有epoch</span><span style="font-size: unset; color: unset; font-family: unset;">）</span></div><div>②<span style="font-weight: bold;">server3收到proposal2后会提交所有未提交的提议，也就是proposal1和proposal2</span></div><div>（<span style="color: rgb(222, 87, 0); font-weight: bold;">收到更新的proposal，会自动commit之前的proposal</span>）</div><div>③server3没有收到proposal1和proposal2的commit消息，但是在收到UPTODATE消息后，会提交lastZxid之前所有未提交的提议。</div><div><img src="《分布式算法与一致性》_files/Image [1].png" type="image/png" data-filename="Image.png" width="419"/></div><div><br/></div><div>179、【<span style="color: rgb(227, 0, 0); font-weight: bold;">可是zxid中明明包含epoch啊？？</span>】</div><div>【<span style="color: rgb(227, 0, 0); font-weight: bold;">其实能获得epoch，但是这里zxid只用来事务的“先后顺序的排序”，不对epoch做其他处理</span>】</div><div>①Zab pre1.0算法，不能实现保证2</div><div>②本质：位置上都有<span style="color: rgb(50, 135, 18); font-weight: bold;">事务zxid为&lt;z,v&gt;</span>的数据，但数据内容不一样。</div><div>【<span style="color: rgb(222, 87, 0); font-weight: bold;">原因：没有区分epoch</span>】</div><div><img src="《分布式算法与一致性》_files/Image [2].png" type="image/png" data-filename="Image.png" width="425"/></div><div><br/></div><div>180、</div><div>①Zab1.0算法：恢复了broadcast阶段前面3个阶段</div><div>②添加的信息：<span style="font-weight: bold;">nextZxid——下一个提议要用的zxid</span>。</div><div>【<span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">发现：discovery</span>】</div><div>①follower连接leader，发送Follower（F.acceptedEpoch）</div><div>②<span style="color: rgb(222, 87, 0); font-weight: bold;">leader一旦具有大多数follower的连接，则停止接收连接</span>。</div><div>生成epoch大于所有的F.acceptedEpoch，发送leaderinfo（e）</div><div>③follower收到leaderInfo（e）后</div><div>    【1】如果e&gt;F.acceptedEpoch,则F.acceptedEpoch=e,并发送<span style="color: rgb(50, 135, 18); font-weight: bold;">AckEpoch（F.currentEpoch，F.lastZxid）</span></div><div>    【2】<span style="color: rgb(222, 87, 0); font-weight: bold;">如果e==F.acceptedEpoch,则不发送AckEpoch消息，</span></div><div>    【3】<span style="color: rgb(50, 135, 18); font-weight: bold;">如果</span><span style="color: rgb(50, 135, 18); font-weight: bold;">e&lt;F.acceptedEpoch,</span><span style="color: rgb(50, 135, 18); font-weight: bold;">则回到选举阶段</span></div><div>④leader等待收到大多数follower的AckEpoch消息，<span style="color: rgb(50, 135, 18); font-weight: bold;">如果不满足【下面2个条件】，则回到选举阶段</span></div><div>    【1】F.currentEpoch&lt;=L.currentEpoch</div><div>    【2】F.currentEpoch==L.currentEpoch，则F.lastZxid&lt;=L.lastZxid（<span style="color: rgb(227, 0, 0); font-weight: bold;">此处原文中为lastZxid</span>）</div><div>⑤【ZAB1.0算法】区别于【设计的ZAB算法】</div><div>   <span style="color: rgb(227, 0, 0); font-weight: bold;"> 【1】Zab1.0算法中，follower没有发送history给leader，而是leader检查自己是否有最新的history</span>，如果没有则重新选举。</div><div>    <span style="color: rgb(227, 0, 0); font-weight: bold;">【2】在设计的ZAB算法中 ，选举阶段不要求具有最新history的节点成为leader，而通过复制history</span>纠正了该阶段的这个问题</div><div><br/></div><div>181、【<span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">synchronization阶段</span>】+【<span style="color: rgb(222, 87, 0); font-weight: bold;">不发送全部的history，而是发送增量的提议</span>】</div><div>①leader建立一个消息队列+把下面的请求放入队列中</div><div>    【1】follower落后太多，SNAP请求放入队列</div><div>    【2】<span style="color: rgb(222, 87, 0); font-weight: bold;">L.history中找到epoch为F.currentEpoch的最大的zxid，如果F.lastZxid&gt;zxid</span>,也就意味着follower【存在需要跳过的+还缺少一部分】。执行下面2个操作。</div><div>            1、将TRUN（zxid）请求放入队列</div><div>            2、<span style="font-weight: bold;">将大于F.lastZxid的所有提议放入DIFF请求中</span>，将DIFF请求放入队列</div><div>    【3】<span style="color: rgb(222, 87, 0); font-weight: bold;">将NewLeader（e）请求放入队列中</span></div><div>    【4】发送堆积在队列中的请求。</div><div>②<span style="color: rgb(50, 135, 18); font-weight: bold;">follower接收到SNAP、TRUN、DIFF消息后，并不立即应用，而是【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">等待NewLeader消息</span><span style="color: rgb(50, 135, 18); font-weight: bold;">】</span>。</div><div>    【1】变更应用状态</div><div>    【2】设置F.currentEpoch=e</div><div> <span style="color: rgb(222, 87, 0); font-weight: bold;">完成后，发送Ack(e)</span></div><div>③leader收到大多数follower发送的ACK，取得了epoch为e的领导权，成为established leader</div><div><span style="color: rgb(222, 87, 0); font-weight: bold;">并且发送UPTODATE请求，再次开始接受follower的连接，设置nextZxid=（e&lt;&lt;32）+1</span>,</div><div>④follower收到UPTODATE请求，进入下一阶段</div><div><br/></div><div>181+182：①Zab1.0算法处理leader宕机故障<span style="color: rgb(50, 135, 18); font-weight: bold;">【例子】</span></div><div>②</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div>
<hr>
<a name="34865"/>

<div>
<span><div>0、相关资料：</div><div>1、<span style="font-size: unset; color: unset; font-family: unset;">重点：95、98、</span></div><div>2、问题：90（gossip+NTP）、100、</div><div>3、原文错误：</div><div><br/></div><div><br/></div><div>【<font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">P86-第9章：分布式数据库CockroachDB</span></font>】</div><div><br/></div><div>86、①CockRoachDB是一个<span style="color: rgb(222, 87, 0); font-weight: bold;">开源的分布式SQL数据库</span>项目，</div><div>②并且成立了CockRoach Labs公司经营这个开源项目，将其商业化</div><div>③<span style="color: rgb(50, 135, 18); font-weight: bold;">设计来源于Google的Spanner</span></div><div>④隔离级别：可串行化-serializable，<span style="color: rgb(222, 87, 0); font-weight: bold;">比Spanner的外部一致性仍然要差一些</span></div><div><br/></div><div>87、①【主键】到【非主键】的映射</div><div>②【1】按照索引分片，到多个机器</div><div>    【2】多副本，到多个机器</div><div><br/></div><div>88、①把【基于SQL的关系数据模型】转换成【key-value的数据模型】</div><div>②【1】如果SQL命令涉及多个store，则会转换成多个KV命令</div><div>    【2】SQL层从store接收到结果后，组装成SQL的结果集合返回给客户端</div><div>③<span style="color: rgb(222, 87, 0); font-weight: bold;">key space</span>：存储用户数据</div><div>④<span style="color: rgb(222, 87, 0); font-weight: bold;">集群元数据（meta data）</span>：range存储在哪个store里</div><div><br/></div><div>89、①CockRoachBD没有使用独立的组件来存储元数据，<span style="color: rgb(222, 87, 0); font-weight: bold;">将元数据也保存在key space 中</span>，</div><div><span style="color: rgb(50, 135, 18); font-weight: bold;">即通过特定key的前缀</span>，将这些元数据保存在key space的开头部分。</div><div>②<span style="color: rgb(222, 87, 0); font-weight: bold;">元数据分为两级</span>：    </div><div>    【1】meta1：指向meta2</div><div>    【2】meta2：所有用户数据的位置信息</div><div><br/></div><div>90、①meta1的位置信息通<span style="color: rgb(227, 0, 0); font-weight: bold;">过Gossip协议获取。【？？？】</span></div><div>②集群中的每个节点，都会定期通过Gossip协议，<span style="color: rgb(50, 135, 18); font-weight: bold;">将自己负责的【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">所有range的描述符</span><span style="color: rgb(50, 135, 18); font-weight: bold;">】传播给其他节点</span>。</div><div>③<span style="color: rgb(227, 0, 0); font-weight: bold;">副本的复制过程，采用了Raft算法</span></div><div>    【1】写请求：走完整raft算法</div><div>    【2】<span style="color: rgb(222, 87, 0); font-weight: bold;">读请求：出于性能考虑，不走raft算法</span></div><div>④通过租约（lease），控制只有一个副本能够服务于读/写请求</div><div>    【1】拥有租约的副本：leaseholder</div><div>    【2】<span style="color: rgb(227, 0, 0); font-weight: bold;">leaseholder收到请求后，会发给raft leader来处理</span></div><div>    【3】<span style="color: rgb(50, 135, 18); font-weight: bold;">leaseholder和raft leader 不一定是同一个副本，但会尽量让leaseholder和raft leader是同一个副本</span></div><div>⑤<span style="color: rgb(50, 135, 18); font-weight: bold;">时钟偏斜</span>：不同机器之间的时间差异</div><div>⑥并未采用TrueTime这样的分布式时钟API，而是采用【<span style="color: rgb(222, 87, 0); font-weight: bold;">本地系统时钟，即采用NTP来同步节点的本地时钟</span>】<span style="color: rgb(227, 0, 0); font-weight: bold;">【？？？】</span></div><div><span style="color: rgb(227, 0, 0); font-weight: bold;">本质：P91——提前留出时钟误差的多余时间</span>，不进行读写请求</div><div>⑦采用【时钟同步算法+NTP】，能够做到集群中的<span style="color: rgb(222, 87, 0); font-weight: bold;">任意两个节点的时钟误差不超过250ms</span></div><div><br/></div><div>91、①问题：新旧2个租约交替的时，会有250ms的时间两个副本都不能处理读/写请求</div><div>②</div><div><br/></div><div>92+93、【<span style="font-weight: bold; color: rgb(227, 0, 0);">单个事务的执行</span>】</div><div>①<span style="font-weight: bold; color: rgb(222, 87, 0);">两阶段提交</span>：保证原子提交</div><div>②<span style="font-weight: bold; color: rgb(222, 87, 0);">不会把原始的值覆盖成5</span>：<span style="font-weight: bold; color: rgb(50, 135, 18);">而是会把原来的值变成一个intent结构，【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">包括原始的值4，要修改成的值5，transaction record的key</span><span style="font-weight: bold; color: rgb(50, 135, 18);">】</span></div><div>    【1】原始的值：plain value</div><div>    【2】新值：staged value</div><div><br/></div><div>94、【<span style="font-weight: bold; color: rgb(227, 0, 0);">多个事务串行执行</span>】</div><div>①后一个事务，会【帮助前一个事务清除intent】：</div><div>    【1】好处：解决前一个事务出现故障后，遗留的intent被有被清除的问题</div><div>    【2】问题：多个事务同时清理intent</div><div>    【3】解决：清理intent的操作是【幂等的】</div><div>②<span style="font-weight: bold; color: rgb(222, 87, 0);">写操作</span>：遇到之前的intent，就清理掉</div><div>③<span style="font-weight: bold; color: rgb(222, 87, 0);">读操作</span>：如果事务状态是committed，则读取intent中的值，并删除transaction record中的key，让intent变成plain value</div><div><br/></div><div>95、<span style="font-size: unset; color: unset; font-family: unset;">①</span><b style="font-size: unset;"><span style="font-weight: bold; color: rgb(227, 0, 0); font-family: unset; font-size: unset;">【区别于】传统的两阶段提交</span></b></div><div>    【1】区别：CockRoach事务的提交阶段只是一个<span style="color: rgb(222, 87, 0); font-weight: bold;">【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">轻量级的key的写入操作】，提交后的intent清除是【异步处理的】</span></div><div>    【2】只是增加一个【轻量级的key的写入操作】，<span style="color: rgb(227, 0, 0); font-weight: bold;">将【</span><span style="color: rgb(227, 0, 0); font-weight: bold;">前一个事务的提交阶段的成本】转化为【后一个事务的写入和读取阶段的成本】</span></div><div>    【3】<span style="font-weight: bold; color: rgb(50, 135, 18);">如果遇到intent，则要额外读取一次transaction record，在某些情况下，这个成本是不必付出的</span>。<span style="font-weight: bold; color: rgb(227, 0, 0);">但在传统两阶段提交的【提交阶段的成本】在任何情况下都是必须要付出的。</span></div><div>    【4】在非常理想的负载情况下，CockRoachDB的事务相当于只有一个阶段，额外加上一个key的写入。</div><div>    【5】<span style="font-weight: bold; color: rgb(50, 135, 18); font-size: 12pt;">本质：通过添加了transaction record这个key来表示事务的状态，来决定哪个值生效。</span></div><div><span style="font-weight: bold; color: rgb(50, 135, 18); font-size: 12pt;">提交的时候，只是修改了</span><span style="font-size: 12pt; color: rgb(50, 135, 18); font-weight: bold;">transaction record，而不是修改值。</span></div><div><br/></div><div>96、【<span style="font-weight: bold; color: rgb(227, 0, 0);">事务的并发执行</span>】</div><div>①前面介绍了事务的【串行执行】，<span style="font-weight: bold; color: rgb(222, 87, 0);">但串行执行仍然是【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">不切实际</span><span style="font-weight: bold; color: rgb(222, 87, 0);">】的</span>。</div><div><span style="font-weight: bold; color: rgb(50, 135, 18);">【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">真实</span><span style="font-weight: bold; color: rgb(50, 135, 18);">】的CockRoachDB的执行</span>，也就是【并发执行】</div><div>②通过<span style="font-weight: bold; color: rgb(222, 87, 0);">时间戳排序（timestamp ordering）</span>来保证可串行性（serializability）</div><div>    【1】根据serializability理论，<span style="font-weight: bold; color: rgb(50, 135, 18);">如果serializability graph无环</span>，就能保证事务的执行是可串行化的</div><div>    【2】两个不同的事务，操作同一个数据</div><div>            （1）写读冲突</div><div>            （2）读写冲突        </div><div>            （3）写写冲突</div><div>    【3】线【指向】受到冲突的事务</div><div><br/></div><div>97、①<b><font style="color: rgb(227, 0, 0);">时间戳排序技术</font></b></div><div>    【1】事务启动时分配时间戳+【<span style="font-weight: bold; color: rgb(222, 87, 0);">事务中的所有操作，都具有相同的时间戳</span>】</div><div>    【2】根据时间戳，本地判断是否存在冲突</div><div>    【3】只接受【比自己时间戳大】的操作，<span style="font-weight: bold; color: rgb(222, 87, 0);">时间戳大的可以跟小的发生冲突</span></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset; color: unset; font-family: unset;">98、</span><span style="font-size: unset;"><span style="color: rgb(227, 0, 0); font-family: unset; font-size: unset; font-weight: bold;">①注意：</span></span><b style="font-size: unset;"><span style="font-weight: bold; color: rgb(227, 0, 0); font-family: unset; font-size: unset;">【具体执行顺序】和【时间戳大小】是两个数据    </span></b></div><div><b><font style="color: rgb(50, 135, 18);">②本书中没有进行证明</font></b></div><div><br/></div><div>99、①数据的多版本保存：</div><div>在多版本的基础上，<b><font color="#DE5700">清除intent的动作，其实是把intent的标志从key中删除</font></b></div><div><br/></div><div>100、冲突的检测</div><div>①WR冲突：reader遇到一个plain value，<b><font style="color: rgb(227, 0, 0);">后面要读取它的reader都会和它有冲突【？？？】</font></b></div><div><b><font color="#E30000">serializability graph中的冲突，包括已经完成的事务执行过的操作产生的冲突【？？？】</font></b></div><div>②WW冲突：</div><div><span>    【1】writer遇到一个intent，也可能是刚刚提交的一个事务写入的intent还没来得及转化为plain value</span><br/></div><div><span>    【2】writer遇到一个plain value，<b><font style="color: rgb(227, 0, 0);">后面要修改的writer都会和它有冲突【？？？】</font></b><br/></span></div><div>③RW冲突：</div><div>    【1<b><font style="color: rgb(222, 87, 0);">】采用缓存，记录所有读操作的时间戳</font></b><br/></div><div><span>    【2】缓存：固定大小+定期清除</span><br/></div><div><br/></div><div>101、①extend P98：因为事务操作的时间戳，是其所在事务的时间戳</div><div><span>    </span><span>    </span><span>    【1】西安发生的操作可能具有更大的时间戳，后发生的操作可能具有更小的时间戳</span><br/></div><div><span>            【2】<b><font style="color: rgb(50, 135, 18);">【操作的时间戳】与【操作实际发生的时间顺序】可能是完全相反的</font></b><br/></span></div><div><br/></div><div>102、①冲突+【带时间戳的冲突】</div><div><span>    </span><span>    【1】冲突：WR，RW，WW</span><br/></div><div>        <b><font><font color="#328712">【2】带时间戳的冲突：WR，RW，WW，</font><font style="color: rgb(222, 87, 0);">但有些冲突变成可被允许的</font></font></b><br/></div><div>②基于MVCC技术的冲突解决：</div><div><span>    【1】解决的场景：reader遇到一个key，且TS(T)&lt;TS(key)</span><br/></div><div>    【2】<font color="#DE5700"><b>解决办法：不读取【</b><b>前面的写操作写入的数据<span>】，而是读取【历史数据】</span><br/></b></font></div><div><br/></div><div>103、①冲突+【<b>可恢复性</b>】</div><div><span>    【1】</span>reader遇到一个key，intent，则不允许读取。<b><font style="color: rgb(222, 87, 0);">因为可能回滚。</font></b></div><div><span>    【2】reader遇到一个key，plain value，允许读取</span><br/></div><div><br/></div><div>104、①冲突+【没有陈旧读】</div><div>    【1】<b><font style="color: rgb(50, 135, 18);">与前面章节介绍的陈旧读不同</font></b>，CockRoachDB的陈旧读<b><font style="color: rgb(222, 87, 0);">不是源于【多副本数据存储】，而是源于【机器间的时钟误差】</font></b><br/></div><div><span>    【2】解决：</span><br/></div><div><span>    </span><span>    </span><span>    （1）比较【</span>近<span>】的将来时间：<b><font style="color: rgb(222, 87, 0);">为了防止陈旧读，T不被允许执行</font></b><br/></span></div><div><span>    </span><span>    </span><span>    （2）比较【</span>远<span>】的将来时间：<b><font style="color: rgb(50, 135, 18);">采用MVCC，T被允许执行，从快照中读取。</font></b><br/></span></div><div><span>    【3】<b><font style="color: rgb(227, 0, 0);">本质：把【</font></b></span><span style="font-weight: bold; color: rgb(227, 0, 0);">时间误差的最大值</span><span><b><font style="color: rgb(227, 0, 0);">】纳入计算</font></b><br/></span></div><div><span><br/></span></div><div>104、</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div>
<hr>
<a name="34863"/>

<div>
<span><div>0、相关资料：</div><div>    ①《Google-Spanner论文的思考》<a href="https://www.jianshu.com/p/6ae6e7989161" style="font-size: unset; font-family: unset;">https://www.jianshu.com/p/6ae6e7989161</a></div><div>1、<span style="font-size: unset; color: unset; font-family: unset;">重点：70、76、80、83、</span></div><div>2、问题：63、67、【隔离级别：68+71】，【76：MVCC，两阶段锁】，【<span style="font-weight: bold; color: rgb(227, 0, 0);">77-79</span>】、【<span style="font-weight: bold; color: rgb(227, 0, 0);">82-83</span>】、【<b><font style="color: rgb(227, 0, 0);">84</font></b>】</div><div>3、原文错误：【75+83：TT.after(s)】、</div><div><br/></div><div><br/></div><div>【<span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">P60-第7章：协调服务zookeeper</span>】</div><div>【<span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">P69-第8章：Google的Spanner数据库</span>】</div><div><br/></div><div><br/></div><div>60、zookeeper功能</div><div>①配置管理：主动通知，配置有变化</div><div>②组员</div><div>③选主</div><div>④<span style="color: rgb(222, 87, 0); font-weight: bold;">分布式锁：类似于选主</span></div><div><br/></div><div>61、zookeeper数据模型：</div><div>数据树（data tree），znode，路径（path）</div><div><br/></div><div>62、①常规节点，临时节点</div><div>②znode下节点的【顺序属性】</div><div>③观察器（watch），通知（notification）</div><div>④ 会话（session），超时时间（timeout）</div><div><br/></div><div>63、①zookeeper外部接口</div><div>②zookeeper架构【？？？】</div><div><br/></div><div>64、①一个服务由多个server组成</div><div>    【1】请求处理器 （request processor）</div><div>    【2】原子广播（atomic broadcast）</div><div>    【3】多副本的数据库（replicated database）</div><div>②zookeeper采用<span style="color: rgb(222, 87, 0); font-weight: bold;">首要备份模式</span></div><div>写请求由首要进程进行，<span style="color: rgb(50, 135, 18); font-weight: bold;">读请求所有进程都可以（备份进程+首要进程）</span></div><div>③<span style="color: rgb(222, 87, 0); font-weight: bold;">写请求</span>被【请求处理器】转化成一个<span style="color: rgb(222, 87, 0); font-weight: bold;">事务</span>，交给【原子广播组件】继续处理</div><div>transaction被简写成txn</div><div>④【<span style="color: rgb(50, 135, 18); font-weight: bold;">原子广播组件</span>】<span style="color: rgb(50, 135, 18); font-weight: bold;">采用的是【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">Zab算法</span><span style="color: rgb(50, 135, 18); font-weight: bold;">】</span></div><div>⑤zookeeper中，<span style="color: rgb(222, 87, 0); font-weight: bold;">Zab中的投递操作</span>，就是将【事务】应用到【本地数据库】</div><div>⑥为了简化：Zab选出的leader就是请求处理器的首要进程</div><div>⑦<span style="color: rgb(222, 87, 0); font-weight: bold;">管道（pipeline）：同时处理多个请求</span></div><div><span style="color: rgb(222, 87, 0); font-weight: bold;">（基于多个不同功能的组件）</span></div><div><br/></div><div>65、【<span style="color: rgb(227, 0, 0); font-weight: bold;">zookeeper的实现细节</span>】</div><div>①客户端异步处理：</div><div>客户端请求后，不等待这个操作的响应</div><div><br/></div><div>66、①请求处理器：</div><div>    【1】问题：<span style="color: rgb(50, 135, 18); font-weight: bold;">客户端请求不是【幂等的】。</span></div><div><span style="color: rgb(222, 87, 0); font-weight: bold;">                        而Zab算法在恢复（recovery）的过程中，会重复投递一个提议。</span></div><div>    【2】做法：将【客户端请求】转化为【状态变更（事务）】</div><div>                      <span style="color: rgb(50, 135, 18); font-weight: bold;">  本质：添加了【版本】</span></div><div>    【3】条件（conditional）操作：比如在setData操作中制定了版本。</div><div><br/></div><div>67+68、原子广播</div><div>①是Zab算法的一个实现</div><div>②<span style="color: rgb(50, 135, 18); font-weight: bold;">在zookeeper原子广播组件中，不属于Zab算法的一个实现细节</span></div><div>③<span style="color: rgb(227, 0, 0); font-weight: bold;">zookeeper的一致性达到【顺序一致性</span><span style="font-size: unset; color: rgb(227, 0, 0); font-family: unset; font-weight: bold;">】</span></div><div>    【1】follower收到转发的回复后需要等待，直到这个事务在本地投递后，才会给客户端返回成功</div><div>    【2】原因：是首要备份模式，备份进程能够处理【读请求】</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>【<span style="font-weight: bold; color: rgb(227, 0, 0); font-size: 12pt;">P69：第8章-Google的Spanner数据库</span>】</div><div><br/></div><div>69、①【1】2012年，Google发表了一篇关于Spanner的论文，<span style="font-weight: bold; color: rgb(222, 87, 0);">讲解了Spanner的实现细节</span></div><div>【2】2017年，Google发表了关于Spanner二代的论文，<span style="font-weight: bold; color: rgb(222, 87, 0);">如何在Spanner一代的基础上添加一个SQL层。</span></div><div>②Spanner数据模型</div><div>    【1】<span style="font-weight: bold; color: rgb(222, 87, 0);">带模式的半关系型表：schematized semi-relational table</span></div><div>    【2】查询语言：query language</div><div>    【3】通用事务：general-purpose transaction</div><div><br/></div><div>70、①带模式的半关系型表</div><div>    【1】数据库+表结构+行列+主键</div><div>    【2】看起来与【关系型数据库】类似</div><div>    【3】但Spanner并不是一个 关系型数据库，实际的数据模型更类似于<span style="font-weight: bold; color: rgb(50, 135, 18);">【键值存储】，也就是主键到非主键的映射，且按照主键排序</span></div><div>    【4】<span style="font-weight: bold; color: rgb(227, 0, 0);">分布式数据库，所以不包含【外键】，而使用【层级关系（hierarchy）】</span></div><div>           （1）用DIRECTORY关键字表示</div><div>           （2）实现级联删除</div><div><br/></div><div>71、通用事务</div><div>① 【1】读事务，写事务</div><div>    <span style="font-size: unset; color: unset; font-family: unset;">【2】只读事务：Spanner系统自动选择了【</span><span style="font-size: unset;"><span style="font-family: unset; font-size: unset; font-weight: bold; color: rgb(222, 87, 0);">最新的时间的snapshot</span></span><span style="font-size: unset; color: unset; font-family: unset;">】读取数据</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">    【3】快照读事务：</span><span style="color: rgba(0, 0, 0, 0); font-family: unset; font-size: unset;">【</span><b style="font-size: unset;"><span style="font-weight: bold; color: rgb(222, 87, 0); font-family: unset; font-size: unset;">用户指定一个时间的snapshot</span></b><span style="color: rgba(0, 0, 0, 0); font-family: unset; font-size: unset;">】，</span><span style="font-size: unset; color: unset; font-family: unset;">读取数据</span></div><div>②<span style="font-weight: bold; color: rgb(222, 87, 0);">Spanner</span><span style="font-weight: bold; color: rgb(222, 87, 0);">只有1种</span><span style="font-weight: bold; color: rgb(222, 87, 0);">隔离级别：可串行化Serializable</span></div><div>    【1】传统数据库：RR（repeatable read）隔离级别，但会有幻读异常</div><div>    【2】<span style="font-weight: bold; color: rgb(50, 135, 18);">使用Spanner时，不用考虑数据正确性问题，Spanner不会出现任何异常现象</span></div><div>            唯一能做的：合理使用【只读事务+快照读事务】，以达到更好的性能</div><div><br/></div><div>72、【Spanner的架构】</div><div>①数据+<span style="font-weight: bold; color: rgb(222, 87, 0);">多</span><span style="font-weight: bold; color: rgb(222, 87, 0);">版本</span>：</div><div>        （key,timestamp）-&gt;string</div><div>②宇宙（universe）+区域（zone）：</div><div>        整体结构+多副本</div><div><br/></div><div>73、①这个集合可以被拆分成多个分片（tablet）（split）</div><div>②使用<span style="font-weight: bold; color: rgb(222, 87, 0);">分布式文件系统Colossus</span>：    </div><div>        是<span style="font-weight: bold;">GFS的改进，突破了GFS的名字空间的限制，可以保存更多数量的文件</span></div><div>③Spanner通过【<span style="font-weight: bold; color: rgb(227, 0, 0);">paxos算法</span>】将tablet复制到多个zone中</div><div>④zone可以是不同的数据中心，甚至分布在<span style="font-weight: bold; color: rgb(222, 87, 0);">不同的大陆（美洲和亚洲）上，一般会具有非常高的【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">广域网级别的延迟</span><span style="font-weight: bold; color: rgb(222, 87, 0);">】</span></div><div>⑤Spanner的paxos<span style="font-weight: bold; color: rgb(50, 135, 18);">实现了pipeline</span></div><div>    【1】单个事务执行时间仍然是广域网级别</div><div>    【2】整体会有很高的吞吐量</div><div><br/></div><div>74、①在Spanner中，Paxos复制的作用，更多是实现<span style="font-weight: bold; color: rgb(222, 87, 0);">【数据跨zone】，让数据可以就近访问</span></div><div>②TRUETime的API来返回时间：<span style="font-weight: bold; color: rgb(50, 135, 18);">不会返回一个【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">确定的时间</span><span style="font-weight: bold; color: rgb(50, 135, 18);">】，而是返回一个【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">时间范围</span><span style="font-weight: bold; color: rgb(50, 135, 18);">】</span></div><div><br/></div><div>75、①TT.now( )：时间范围【earliest,latest】</div><div>②<span style="font-weight: bold; color: rgb(227, 0, 0);">判断两次调用的先后关系</span></div><div>    【1】TT.after(t)==true——now().latest&lt;t——【<span style="color: rgb(222, 87, 0); font-weight: bold;">绝对还没来</span>】</div><div>    【2】 <span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">TT.before(t)==true——t&lt;now().earliest——【</span><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(222, 87, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">绝对已经过去</span><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">】</span></div><div>③paxos算法：leader+slave</div><div>④<span style="font-weight: bold; color: rgb(50, 135, 18);">两阶段提交：协调者+参与者</span></div><div><br/></div><div>76、①<span style="font-weight: bold; color: rgb(50, 135, 18);">MVCC：多版本并发控制</span></div><div>维持一个数据的多个版本，使得读写操作没有冲突</div><div>②<span style="font-weight: bold; color: rgb(50, 135, 18);">两阶段锁（two phase locking）</span>：</div><div>【加锁阶段+解锁阶段】，<span style="font-weight: bold; color: rgb(222, 87, 0);">加锁和解锁操作不能交叉执行（同一个事务内）</span></div><div><a href="https://www.cnblogs.com/lyhabc/p/4753540.html">https://www.cnblogs.com/lyhabc/p/4753540.html</a></div><div>两段锁协议和防止死锁的一次封锁法的异同之处。</div><div>【1】<span style="font-weight: bold; color: rgb(222, 87, 0);">一次封锁法</span>：要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此<span style="font-weight: bold; color: rgb(222, 87, 0);">一次封锁法遵守两段锁协议</span></div><div>【2】<span style="font-weight: bold; color: rgb(222, 87, 0);">两段锁协议</span>：并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务<span style="font-weight: bold; color: rgb(222, 87, 0);">可能发生死锁</span>。</div><div><br/></div><div>77、</div><div><br/></div><div><br/></div><div>80、①Spanner目录</div><div>【1】基于一个假设：实际的应用开发中，有关联的表往往会被组织在一个事务中，一起被更新或查询</div><div>【2】<span style="font-weight: bold; color: rgb(222, 87, 0);">通过层级式的数据存储</span>，<span style="font-weight: bold; color: rgb(50, 135, 18);">将这些表交织在一起，往往会让多个表中有关联的数据，落在一个tablet</span>中</div><div>【3】一个tablet中保存的数据可以被分为多个目录，<span style="font-weight: bold; color: rgb(222, 87, 0);">一个目录中所有key都具有相同的前缀（prefix）</span></div><div>②paxos的作用</div><div>    【1】数据复制到多个【副本】</div><div>    【2】<span style="font-weight: bold; color: rgb(227, 0, 0);">保证两阶段提交在Spanner中的应用</span>。</div><div>            （1）少数节点故障，不会影响继续运行</div><div>            （2）<span style="font-weight: bold; color: rgb(222, 87, 0);">leader宕机，其他副本被选为leader后，也可以【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">根据</span><span style="color: rgb(222, 87, 0); font-weight: bold;">加锁信息对数据重新进行加锁</span><span style="font-weight: bold; color: rgb(222, 87, 0);">】，继续承担两阶段提交的角色。</span></div><div><br/></div><div>81、①spanner支持【可串行化】，实际提供了<span style="font-weight: bold; color: rgb(50, 135, 18);">更严格的一致性：外部一致性</span></div><div>②<span style="font-weight: bold; color: rgb(222, 87, 0);">外部一致性</span>：对于任意两个事务T1和T2，即使两个事务分别在地球的两侧，如果事务T2在事务T1完成提交之后再提交，那么事务T2的时间戳一定大于事务T1的时间戳</div><div>    2个特殊场景</div><div>    【1】两个没有交集的读事务和写事务，也满足外部一致性</div><div>    【2】只读事务和快照读事务，也满足外部一致性</div><div>②替代方案：</div><div><span style="font-weight: bold; color: rgb(50, 135, 18);">        【1】全局授时服务：是集中式方案——【全局授时服务timestamp oracle】</span></div><div><span style="font-weight: bold; color: rgb(50, 135, 18);">        【2】TrueTime：是纯粹的分布式方案。</span></div><div><br/></div><div>82、①<span style="font-weight: bold; color: rgb(222, 87, 0);">调用系统时间函数，会导致【先执行的事务，被分配了较大的时间戳】</span>，而实际后执行的事务，被分配了较小的时间戳，从而不能导致外部一致性。</div><div>②Spanner<span style="font-weight: bold; color: rgb(50, 135, 18);">采用commit wait方式</span>来适应这种误差。</div><div>事务启动后，分配一个时间戳，t_start&lt;s&lt;t_end</div><div>③<span style="font-weight: bold; color: rgb(222, 87, 0);">Spanner实现方式：这两个说法好像一样【？？？】</span></div><div><span style="font-weight: bold;">    【1】选择事务时间戳，时间戳【大于TT.now().latest】</span></div><div><span style="font-weight: bold;">    【2】直到TT.after(s)==true后，才提交应用事务</span></div><div><br/></div><div>83、①t_start &lt; now() &lt; now().latest &lt; s</div><div>②TT.after(s)==true，意味着s小于now().earliest【<span style="font-weight: bold; color: rgb(227, 0, 0);">这里说法跟P75不一样？？？</span>】</div><div>注意：这里是第二次调用now()</div><div>③s &lt; now().earliest &lt; now() &lt; t_end</div><div>④<span style="font-weight: bold; color: rgb(50, 135, 18);">结合【1+3】，得到t_start &lt; s &lt; t_end</span></div><div>⑤<span style="font-weight: bold; color: rgb(50, 135, 18);">本质：调用2次now()函数，大于第一个的latest，小于第二个的earliest</span></div><div>⑥【1】导致事务需要<span style="font-weight: bold; color: rgb(222, 87, 0);">【更长的时间】才能结束</span></div><div>    【2】实际上和paxos协议的执行时间是重叠的，<span style="color: rgb(222, 87, 0); font-weight: bold;">所以并不是【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">空等待】</span></div><div>⑦根据Spanner读写事务的执行过程<span style="font-weight: bold; color: rgb(227, 0, 0);">【？？？】</span></div><div><br/></div><div>84、①多副本的分布式系统，要想达到线性一致性，<span style="font-weight: bold; color: rgb(50, 135, 18);">【读操作】需要和写操作一样与其他副本交互</span></div><div>    【1】zookeeper：在读之前，先进行sync</div><div>    【2】mongodb：在读之前，先进行一个空写操作</div><div>②primary角色通过<span style="font-weight: bold; color: rgb(50, 135, 18);">租约（lease）</span>来维护自己的primary地位</div><div><span style="font-weight: bold; color: rgb(222, 87, 0);">    【1】如果primary持有【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">从大多数backup发来的租约</span><span style="font-weight: bold; color: rgb(222, 87, 0);">】，那么它就可以单方面进行读操作，而不用联系其他副本。</span></div><div>    【2】如果发生网络分区，那么新选出来的primary<span style="font-weight: bold; color: rgb(222, 87, 0);">在所有旧的primary的租约过期之前</span>，是不能处理任何客户端请求的。</div><div>    【3】优点：大大提高了读的性能</div><div>    【4】<span style="font-weight: bold; color: rgb(50, 135, 18);">问题：在发生网络分区时，旧的租约到期前，新的primary和旧的primary都是不能处理客户端请求的</span>。处于不可用状态。</div><div>    【5】<span style="font-weight: bold; color: rgb(227, 0, 0);">本质：避免读操作时，联系其他副本的开销。</span></div><div><br/></div><div>85、①长租约：10s——在Google的数据中心，非计划的故障是很少发生的，所以长租约是合理的。</div><div>②虽然Spanner的读/写事务不需要进行复制读，<span style="font-weight: bold; color: rgb(50, 135, 18);">但是仍然有【两阶段锁、复制写、两阶段提交</span>】，<span style="font-weight: bold; color: rgb(222, 87, 0);">所以读/写事务的性能表现不是强项。</span></div><div>③优势：只读事务和快照读事务，是保持外部一致性的、无锁的读取，<span style="font-weight: bold; color: rgb(50, 135, 18);">所以Spanner更适合【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">读多写少</span><span style="font-weight: bold; color: rgb(50, 135, 18);">】的场景</span></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div>
<hr>
<a name="34861"/>

<div>
<span><div>0、相关资料：</div><div>1、<span style="font-size: unset; color: unset; font-family: unset;">重点：</span></div><div>2、问题：22、25、</div><div>3、原文错误：</div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">【</span><span style="font-size: 12pt; color: rgb(50, 135, 18); font-weight: bold;">P30：</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">Google的BigTable系统</span><span style="font-size: 12pt;">】</span></div><div><span style="font-size: 12pt;">【</span><span style="font-size: 12pt; color: rgb(50, 135, 18); font-weight: bold;">P39：</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">文档数据库MongoDB</span><span style="font-size: 12pt;">】</span></div><div><span style="font-weight: bold; font-size: 12pt;">【</span><span style="font-weight: bold; color: rgb(50, 135, 18); font-size: 12pt;">P54：</span><span style="font-weight: bold; color: rgb(227, 0, 0); font-size: 12pt; font-family: 微软雅黑; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">消息队列RabbitMQ</span><span style="font-weight: bold; font-size: 12pt; font-family: 微软雅黑; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">】</span></div><div><br/></div><div><br/></div><div>31、①key-value型的NOSQL数据库，虽然支持行列的数据模型</div><div>②【1】行</div><div>    【2】列</div><div>    【3】列族：<span style="color: rgb(222, 87, 0); font-weight: bold;">列中，能够再细分属性。</span></div><div><br/></div><div><span style="font-weight: bold;">32、①操作一行内的多个列</span>，<span style="color: rgb(222, 87, 0); font-weight: bold;">保证原子性。</span></div><div>④每个单元格都包含<span style="color: rgb(50, 135, 18); font-weight: bold;">多个版本的数据</span>，这些版本通过【时间戳】来标识</div><div><br/></div><div>33、①通常这个<span style="color: rgb(222, 87, 0); font-weight: bold;">Map</span>很大，BigTable会按row key对它进行<span style="color: rgb(222, 87, 0); font-weight: bold;">切分</span>，每一份叫作<span style="color: rgb(222, 87, 0); font-weight: bold;">tablet</span></div><div><br/></div><div>34、<span style="color: rgb(227, 0, 0); font-weight: bold;">BigTable的架构</span>：</div><div>    GFS、chubby、client、master、tablet server</div><div>①GFS：日志文件+数据文件爱你</div><div>②一个tablet server管理多个tablet</div><div>③主节点（master）把tablet分配给tablet</div><div>④客户端：嵌入在应用中的一个库（library），<span style="color: rgb(222, 87, 0); font-weight: bold;">或叫作SDK</span></div><div>对tablet server操作，GFS客户端，chubby客户端</div><div>⑤<span style="color: rgb(50, 135, 18); font-weight: bold;">chubby：分布式锁服务，类似于zookeeper</span></div><div>    【1】选举master</div><div>    【2】维护tablet server：心跳信息</div><div>    【3】BigTable集群的基础信息（指向metadata表）</div><div><br/></div><div>35、①metadata表：元数据，也储存在tablet中</div><div><br/></div><div>36、①BigTable的三层树结构</div><div>【1】chubby file：指向metadata表的第一行</div><div>【2】metadata表的剩余部分</div><div>【3】很多个tablet</div><div>②<span style="color: rgb(222, 87, 0); font-weight: bold;">指派</span>：将<span style="color: rgb(222, 87, 0); font-weight: bold;">tablet server</span>的地址，写入这个<span style="color: rgb(222, 87, 0); font-weight: bold;">tablet</span>在<span style="color: rgb(222, 87, 0); font-weight: bold;">metadata表</span>的这一行中。</div><div>③如果tablet server宕机，则将它管理的tablet放入【未指派集合】</div><div><br/></div><div>37、①tablet保存在GFS文件中</div><div>【1】日志文件：提交日志</div><div>【2】数据文件：<span style="color: rgb(222, 87, 0); font-weight: bold;">SSTable格式【？？？】</span></div><div>②加载<span style="color: rgb(50, 135, 18); font-weight: bold;">tablet：GFS文件</span></div><div>从GFS中读取日志文件，从【重做点】开始，<span style="color: rgb(50, 135, 18); font-weight: bold;">重新执行一遍redo log，在内存中重建【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">memtable</span><span style="color: rgb(50, 135, 18); font-weight: bold;">】（注意：不是metaTable）</span></div><div>③<span style="color: rgb(222, 87, 0); font-weight: bold;">memtable</span>：处理读写请求，最近写入的数据会被保存在内存的buffer中，这个buffer叫作memtable</div><div>④<span style="color: rgb(222, 87, 0); font-weight: bold;">SSTable文件</span>：比较旧的数据会保存在SSTable文件中</div><div>⑤对tablet的读写请求：</div><div>    【1】写：日志文件中追加1条redo记录，数据被插入memtable中</div><div>    【2】读：先在memtable中查找，如果没有则查SSTable文件</div><div><br/></div><div>38、①小合并：<span style="color: rgb(50, 135, 18); font-weight: bold;">memTable达到一定长度后，变成SSTable文件</span></div><div>②融合合并：<span style="color: rgb(222, 87, 0); font-weight: bold;">多个</span>SSTable文件，变成1个SSTable文件</div><div>③大合并：<span style="color: rgb(222, 87, 0); font-weight: bold;">全部</span>SSTable文件，变成1个SSTable文件</div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">【</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">文档数据库MongoDB</span><span style="font-size: 12pt;">】</span></div><div><br/></div><div>39、①MongoDB：<span style="color: rgb(222, 87, 0); font-weight: bold;">介于【关系型数据库和非关系型数据库】之间</span></div><div>②集合（collection）：数据表</div><div>文档（document）：一条具体数据</div><div><br/></div><div>40、①<span style="color: rgb(222, 87, 0); font-weight: bold;">主从模式</span>：</div><div>    【1】次要副本不工作，连读请求也不处理。</div><div>    【2】存储冗余数据，准备接替首要副本</div><div><br/></div><div>41、①异步写入+丢失更新：</div><div>    【1】原因：无确认</div><div>    【2<span style="color: rgb(50, 135, 18); font-weight: bold;">】解决：写入确认——阻塞的和非阻塞的</span></div><div>②重启+丢失更新：</div><div>    <span style="color: rgb(50, 135, 18); font-weight: bold;">【1】原因：未持久化</span></div><div><span style="color: rgb(50, 135, 18); font-weight: bold;">    【2】解决：</span><span style="color: rgb(227, 0, 0); font-weight: bold;">写入日志【没有具体进行了写操作，只是记录了写操作的指令】</span></div><div><br/></div><div>43、oplog</div><div>①MongoDB的机制，<b><font style="color: rgb(222, 87, 0);">观察每个集合的数据变化</font></b>，一旦有数据变化，就将这个数据变化整理成一条操作记录。</div><div>写入名为<b><font style="color: rgb(50, 135, 18);">oplog的特定集合</font></b>中。</div><div>oplog中的操作记录<b><font style="color: rgb(50, 135, 18);">是幂等的，可以反复应用</font></b></div><div>②oplog<span style="color: unset; font-family: unset; font-size: unset;">不同于日志，</span><b style="font-family: unset; font-size: unset; color: unset;"><font style="color: rgb(222, 87, 0);">虽然它们记录的操作记录是类似的，</font></b><span style="font-family: unset; font-size: unset;"><b><font style="color: rgb(50, 135, 18);">但使用oplog是专门为了把数据复制多份</font></b><font color="rgba(0, 0, 0, 0)">。</font></span></div><div>③<b><font style="color: rgb(222, 87, 0);">封顶集合</font></b>：如果存储的文档超过这个数量，则最早存入的文档会被自动删除</div><div>④每条操作记录是【幂等+确定的】，形成了【<b><font style="color: rgb(227, 0, 0);">复制状态机</font></b>】</div><div><b><font style="color: rgb(227, 0, 0);">确定的：x=1是确定的，x=currentTime()就不是确定的</font></b></div><div><br/></div><div>44、①无副本确认，导致丢失更新</div><div>解决：副本写入通知</div><div><br/></div><div>45、①<b><font style="color: rgb(222, 87, 0);">不正常选主</font></b>：导致丢失更新</div><div>②解决：</div><div><span>    【1】第一部分：选主协议protocol v0</span><br/></div><div><span><span>    【2】第二部分：大多数写</span><br/></span></div><div><br/></div><div>46、<b><font style="color: rgb(222, 87, 0);">选主协议<font>protocol v0</font></font></b></div><div>①oplog有一个optime的属性</div><div>②<b><font style="color: rgb(222, 87, 0);">选主依据</font></b>：选择optime大的次要副本，因为optime越大的次要副本一定复制了更多的操作记录</div><div>③MongoDB选主依据：</div><div><span>    【1】要成为新的首要副本，需要大多数成员同意。</span><br/></div><div><span><span>    【2】1个成员，1次选举只能投票1次</span><br/></span></div><div><span>    【3】<b><font style="color: rgb(50, 135, 18);">不同意optime比自己小的</font></b><br/></span></div><div>④<b><font style="color: rgb(50, 135, 18);">问题：A包含最新数据，B不包含</font></b>。</div><div>C同意了B，B就有2票了。</div><div>⑤<b><font style="color: rgb(222, 87, 0);">解决：大多数写</font></b></div><div>保证参与选举的<b><font style="color: rgb(50, 135, 18);">【大多数集合】一定有最新数据。</font></b></div><div><b><font style="color: rgb(227, 0, 0);">⑥【投票机制必须结合大多数写】</font></b></div><div><br/></div><div>47、<font style="color: rgb(222, 87, 0);"><b>脑裂：数据不一致</b></font></div><div>①首要副本主动下台</div><div>【1】首要副本，联系不上【大多数副本】</div><div>【2】<b><font style="color: rgb(50, 135, 18);">网络分区恢复后，发现【其他首要副本】（</font><font style="color: rgb(222, 87, 0);">如果没有及时通过心跳，发现自己联系不上大多数</font><font style="color: rgb(50, 135, 18);">）</font></b></div><div>②<b><font style="color: rgb(222, 87, 0);">解决：大多数写</font></b></div><div>采用后，只会有【未确认更新】</div><div><br/></div><div>49、<b><font style="color: rgb(222, 87, 0);">缺失任期消息</font></b>：丢失更新</div><div>①大多数写：能解决【丢失更新消息】，但不能解决【丢失已经确认的消息】</div><div>②<b><font style="color: rgb(227, 0, 0);">问题：【ABA场景】</font></b></div><div>③其实大概率并不会出现</div><div><span>    【1】B成为首要副本之前，A已经下台，不再接受客户端写入了</span><br/></div><div><span><span>    【2】新的首要副本一般会有更大的optime</span><br/></span></div><div><br/></div><div>50、<b><font style="color: rgb(222, 87, 0);">时钟偏斜</font></b></div><div>①加剧ABA问题的后果</div><div>②<b>时钟偏斜（clock skew）</b>：机器之间的时间差异</div><div><br/></div><div>51、<b><font style="color: rgb(222, 87, 0);">选主协议protocol v1：任期term</font></b></div><div>①解决：optime——<b><font style="color: rgb(50, 135, 18);">增加了任期term</font></b></div><div>②比较optime时，优先比较任期，<b><font style="color: rgb(222, 87, 0);">则A就不会成为首要副本</font></b></div><div><span style="color: rgb(222, 87, 0);"><b><br/></b></span></div><div><span style="color: rgb(222, 87, 0);"><b>52、</b></span><span style="font-weight: bold; color: rgb(222, 87, 0);">脏读：被回滚的数据</span></div><div>①原因：被回滚</div><div>②<b><font style="color: rgb(50, 135, 18);">解决：大多数读</font></b></div><div><font>③大多数读不会读取【</font><b><font style="color: rgb(222, 87, 0);">数据的最新版本</font></b><font>】，只会读取已经得到【</font><b><font style="color: rgb(222, 87, 0);">大多数确认的历史版本</font></b><font>】</font></div><div>④大多数读——<b><font style="color: rgb(227, 0, 0);">不会阻止对同一个数据的【新的写操作】</font></b></div><div>首要副本在等待前一个写操作的次要副本的通知时，可以再进行一个写操作</div><div><br/></div><div>53、<b><font style="color: rgb(222, 87, 0);">陈旧读：脑裂（网络分区）</font></b></div><div>①原因：【旧的首要副本】仍然可以处理【读请求】</div><div>②解决：<b><font color="#E30000">线性读——在读之后阻塞等待，做 1 次空的写操作</font></b></div><div><span>    </span><span>    </span>保证了首要副本不是处于网络分区的【少数成员一侧】</div><div><br/></div><div><br/></div><div><br/></div><div>【<b><font style="color: rgb(50, 135, 18); font-size: 12pt;">P54</font><font style="color: rgb(227, 0, 0); font-size: 12pt;"> <span style="font-family: 微软雅黑; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">消息队列RabbitMQ</span></font></b>】</div><div><br/></div><div>54、①broker（中介者）：rabbitMQ的机器</div><div>进程不被成为server，而被成为broker</div><div><br/></div><div>55、①队列：发布+订阅</div><div>②【<b><font style="color: rgb(227, 0, 0);">名字不同</font></b>】镜像队列：复制+副本</div><div>③RabbitMQ把1条消息成功写入【所有镜像】后，才会处理下一条消息</div><div>    【<b><font style="color: rgb(222, 87, 0);">问题：处理消息的速度，取决于写入最慢的队列</font></b>】<br/></div><div><br/></div><div>56、①有队列宕机+【RabbitMQ会新建一个“新的空镜像”，让队列满足policy对数量的定义】</div><div>②新镜像并不试图追齐master，它只接受其加入之后的消息</div><div><br/></div><div>57、①追齐方式</div><div><span>    </span>【1】方式1-<b><font style="color: rgb(222, 87, 0);">自然追齐</font></b>：消费者不断消费，之前的消息会不断从master中删除，最终会达到【同步状态】。</div><div><span>    </span><span>    RabbitMQ没有采用很多分布式系统采用的【一致】这个词</span><br/></div><div>    【2】方式2-<b><font style="color: rgb(222, 87, 0);">强制同步</font></b>：停止master写入新消息，新镜像从master拉取所有消息。<br/></div><div>②<b><font style="color: rgb(222, 87, 0);">意外宕机</font></b>的master切换<b><font style="color: rgb(50, 135, 18);">：保证RabbitMQ尽量可用</font></b></div><div><span>    【1】方式1：最早加入队列的镜像会成为新的master（但是该镜像不一定达到同步状态）</span><br/></div><div><span><span>    【2】方式2：只有达到【同步状态】的镜像才能成为新的master</span><br/></span></div><div>③<b><font style="color: rgb(222, 87, 0);">主动运维</font></b>后的master切换：<b><font style="color: rgb(50, 135, 18);">保证数据尽量不丢失</font></b></div><div><span>    优先同步状态，然后最早进入</span><br/></div><div><span>    【1】存在有同步状态的：成为新master</span><br/></div><div><span><span>    【2】不存在：无master，集群不能提供服务</span><br/></span></div><div><span><br/></span></div><div><span>58、①脑裂（网络分区）</span></div><div><span>【1】<b><font style="color: rgb(222, 87, 0);">方式1-暂停少数分区</font></b></span></div><div><span><span>    （1）master在大多数分区：恢复后，少数分区</span><br/></span></div><div><span><span>    （2）master在少数分区：如果大多数分区中成为【新的master的镜像】不是具有同步状态的，就会丢失数据</span><br/></span></div><div><span>【2】<b><font style="color: rgb(222, 87, 0);">方式2-让所有分区独立运行</font></b></span></div><div><span>    </span><span>    网络恢复后，需要选择丢弃哪个</span><br/></div><div><br/></div><div>59、确认机制</div><div>①生产者：存入所有镜像后，返回确认</div><div>②消费者：</div><div><span>    【1】超时失败</span><br/></div><div><span><span>    【2】主动回复失败</span><br/></span></div><div><span><br/></span></div><div><span>60、</span></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div>
<hr>
<a name="34359"/>

<div>
<span><div>0、相关资料：</div><div>1、<span style="font-size: unset; color: unset; font-family: unset;">重点：</span></div><div>2、问题：22、25、</div><div>3、原文错误：</div><div><br/></div><div><br/></div><div><font style="font-size: 12pt;">【<span style="color: rgb(227, 0, 0); font-weight: bold;">文件系统HDFS：Hadoop相关</span>】（<span style="font-weight: bold; color: rgb(50, 135, 18);">缺乏设计思想，不够全面</span>）</font></div><div><br/></div><div><br/></div><div>19、①hflush：将数据强制写入磁盘</div><div>②<span style="color: rgb(222, 87, 0); font-weight: bold;">与GFS相比，HDFS不支持【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">在任意位置随机写入</span><span style="color: rgb(222, 87, 0); font-weight: bold;">】</span></div><div>③对同一个文件，HDFS不支持【多个写入方同时写入】</div><div><br/></div><div>20、①在HDFS0.21之前，HDFS不支持append和hflush</div><div>②NN：Namenode——用于存储分布式文件系统的【元数据】</div><div>③文件被分成<span style="font-weight: bold; color: rgb(50, 135, 18);">块（block）</span>存储在<span style="font-weight: bold; color: rgb(50, 135, 18);">DataNode（DN）</span>中</div><div><br/></div><div>21、①写：在NN中，在名字空间创建一个对象，代表这个文件</div><div>②写：DN成功写完后发给NN，NN记录这个block与机器之间的对应关系</div><div>③读：客户端向NN发送1个请求，请求中包含文件名和索引号，<span style="color: rgb(222, 87, 0); font-weight: bold;">NN返回3个副本在哪3台机器上的信息</span></div><div>④<span style="color: rgb(222, 87, 0); font-weight: bold;">GFS和HDFS主要在写流程上不同 </span></div><div><br/></div><div>22、①HDFS租约：发给打开某个文件的【客户端】</div><div><span style="color: rgb(50, 135, 18); font-weight: bold;">        GFS租约：发给首要副本【？？？】</span></div><div>②<span style="font-weight: bold; color: rgb(222, 87, 0);">文件pipeline写入</span>：</div><div>    【1】新建文件：NN会为这个 block生成一个新代戳（generation stamp），我们可以认为代戳是一个递增的数值</div><div>    【2】追加写入：<span style="font-weight: bold; color: rgb(222, 87, 0);">NN会把【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">这个文件最后一个block的副本所在的DN</span><span style="font-weight: bold; color: rgb(222, 87, 0);">】返回给客户端</span>。</div><div>                                NN会加大这个block的代戳，即表明这个block已经进入下一代。</div><div>③客户端发送建立pipeline的请求给3个DN，当它收到3个DN的成功回复后，pipeline即建立成功。</div><div><br/></div><div>23、①<span style="font-weight: bold; color: rgb(50, 135, 18);">pipeline的实现图【@@记得补充图】</span></div><div>串行，客户端只需要发送一个请求，数据会自动传递给多个副本（DN）</div><div>②按顺序发送每个包，包发出后，<span style="font-weight: bold; color: rgb(222, 87, 0);">不必等待包的回复</span>即可发送下一个包。（<span style="color: rgb(50, 135, 18);">@@记得补充图</span>）</div><div><br/></div><div>24、①<span style="font-weight: bold; color: rgb(222, 87, 0);">上报block状态（</span>在NN上）</div><div>【1】UnderConstruction：block处于【建立，或追加状态】</div><div>【2】rbw（replica being written to）:为block创建pipeline</div><div>【3】finalized：pipeline关闭后</div><div>【4】committed：NN收到客户端的上报信息</div><div>【5】complete：NN收到DN的上报信息后</div><div> ②关闭文件 ：客户端向NN发送关闭文件的请求后      </div><div>【1】NN检查自身，如果所有block的状态都为block，则关闭</div><div>【2】直到收到<span style="font-weight: bold; color: rgb(222, 87, 0);">至少一个DN</span>上报状态，block状态被标记为complete</div><div><br/></div><div>25、<span style="font-weight: bold; color: rgb(227, 0, 0);">DN的错误</span></div><div>①比如网络发送数据错误、磁盘操作错误</div><div>②DN 自己处理错误</div><div>    【1】状态为rbw的副本，会被加载为<span style="font-weight: bold; color: rgb(222, 87, 0);">rwr（replica wating to be recovered</span>）,表示这个副本要开始进行恢复</div><div>    【2】<span style="font-weight: bold; color: rgb(50, 135, 18);">检查文件的CRC，把文件长度设置为满足CRC校验，不能通过CRC校验的内容将被丢弃【？？？】</span></div><div>③客户端处理DN的错误（<span style="font-weight: bold; color: rgb(222, 87, 0);">管道恢复：pipeline recovery</span>）</div><div>    【1】使用 剩余的DN重新建立pipeline，<span style="font-weight: bold; color: rgb(222, 87, 0);">并向NN要求新代戳</span>（NN会增加代戳）</div><div>    【2】客户端用【新代戳】向【新pipeline】写入数据</div><div><br/></div><div>26、<span style="font-weight: bold; color: rgb(227, 0, 0);">NN的错误</span></div><div>①NN不会持久化存储block的状态，block的状态仅会被保存在内存中。</div><div>②重启后，NN进入【安全模式】</div><div>    【1】所有未关闭的文件的<span style="font-weight: bold; color: rgb(222, 87, 0);">最后一个block</span>会被加载为underConstruction状态，其他的block为Complete状态</div><div>    【2】NN等待DN上报信息：直到<span style="color: rgb(50, 135, 18); font-weight: bold;">至少每个block都收到【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">一个副本</span><span style="color: rgb(50, 135, 18); font-weight: bold;">】的上报信息</span></div><div>        退出安全模式的条件：</div><div>        （1）如果block为Complete，则至少收到一个副本的finalized</div><div>        （2）如果block为UnderConstruction：至少收到一个副本的<span style="color: rgb(222, 87, 0); font-weight: bold;">【rwr、committed、finalized】的其中之一</span></div><div><br/></div><div>27、<span style="font-weight: bold; color: rgb(227, 0, 0);">客户端的错误</span></div><div>①<span style="font-weight: bold; color: rgb(222, 87, 0);">串行一致性</span>：</div><div>    【1】保证只有一个writer</div><div>    【2】问题：writer如果宕机，写入功能就无效了。</div><div>    【3】解决：<span style="font-weight: bold; color: rgb(50, 135, 18);">同步机制（锁机制）（租约机制）</span>——多个writer+锁</div><div>②问题：租约过期</div><div>    【1】不能严格保证只有一个writer写入</div><div>    【2】原因：writer出现【假死、过载、续约包在网络上】，<span style="font-weight: bold; color: rgb(222, 87, 0);">续约就会失败，出现【脑裂】</span></div><div>    【3】<span style="font-weight: bold; color: rgb(222, 87, 0);">解决：租约恢复</span>，防止旧的写入者再写入数据。</div><div>③客户端出错</div><div>    【1】问题：<span style="font-weight: bold;">block不能完成一个完整的文件写入过程</span></div><div>    【2】解决：<span style="font-weight: bold; color: rgb(50, 135, 18);">块恢复（block recovery）</span></div><div>④<span style="font-weight: bold; color: rgb(50, 135, 18);">副本恢复</span>：块恢复过程中，<span style="font-weight: bold; color: rgb(222, 87, 0);">将block保存在每个DN上的副本</span>都进行恢复</div><div><br/></div><div>28、①<span style="font-weight: bold; color: rgb(227, 0, 0);">租约恢复</span>：<span style="font-size: unset;"><span style="font-family: unset; font-size: unset; font-weight: bold; color: rgb(50, 135, 18);">检查文件最后2个block的状态</span></span></div><div>    【1】2个都是complete，则关闭文件</div><div>    【2】Committed或complete，则会<span style="font-weight: bold; color: rgb(222, 87, 0);">等待一段时间（与租约超时的时间一致</span>），再检查，再续租。多次后，依旧不成功，强制关闭。</div><div>    【3】最后1个是UnderConstruction，开始块恢复。并将block状态改为UnderRecovery</div><div>    【4】最后1个是UnderRecovery，说明之前已经开始了块恢复过程，则开始一个新的块恢复过程。多次失败后，会放弃恢复、</div><div><br/></div><div>②块恢复：</div><div>    【1】从block副本所在的所有DN中，选择一个 作为【<span style="font-weight: bold; color: rgb(50, 135, 18);">首要DN】（Primary DataNode：PD）</span></div><div>    【2】NN生成一个新代戳，将block从UnderConstruction改为UnderRecovery。（<span style="font-weight: bold; color: rgb(222, 87, 0);">新的块恢复过程会有更新的代戳</span>，会抢占之前的旧的块恢复过程。）</div><div>    【3】PD让每个DN都执行<span style="font-weight: bold; color: rgb(222, 87, 0);">副本恢复</span>。执行副本恢复过程的副本处于rur（replica UnderRecovery），执行完后，返回PD自己当前状态。</div><div>    【4】PD收到每个DN的副本执行状态。</div><div>            （1）所有DN都异常，则停止块恢复</div><div>            （2）所有DN返回的<span style="font-weight: bold; color: rgb(222, 87, 0);">文件长度为0</span>，则要求NN删除这个block</div><div>            （3）所有DN的状态都为finalized，<span style="font-weight: bold; color: rgb(222, 87, 0);">但副本的长度却不一样</span>，终止快恢复过程。</div><div>    【5】不存在异常<span style="color: rgb(50, 135, 18);">，</span><span style="color: rgb(50, 135, 18); font-weight: bold;">则根据所有副本的【恢复前状态】</span>，选择其中一个副本的文件长度，作为block的长度。</div><div>            优先选更优状态，再次选长度最小的。</div><div>②副本恢复</div><div>【1】</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div>
<hr>
<a name="34351"/>

<div>
<span><div>0、相关资料：</div><div>1、<span style="font-size: unset; color: unset; font-family: unset;">重点：16、</span></div><div>2、问题：</div><div>3、原文错误：</div><div><br/></div><div><br/></div><div><font style="font-size: 12pt;">【</font><font style="font-size: 12pt;"><span style="font-weight: bold; color: rgb(227, 0, 0);">Google的文件系统：GFS</span>】</font></div><div><br/></div><div><br/></div><div>3、①单机器：IOE的昂贵收费</div><div>②领域拆分：【订单子系统、交易仔细用、用户子系统、商品子系统】</div><div><br/></div><div>4、①把数据分散到多个数据库。</div><div>用【<span style="color: rgb(222, 87, 0); font-weight: bold;">数据库中间件</span>】实现分别到多个数据库获得数据，然后把多个结果合并成一个最终结果。</div><div><br/></div><div>5、①互联网公司，往往都有【不能使用join、SQL中必须携带分片id】等要求。</div><div>在这些使用要求下，受限的SQL数据库的能力与NOSQL数据库相比，已经没有明显的优势</div><div><br/></div><div>8、①<span style="color: rgb(50, 135, 18); font-weight: bold;">POSIX的标准文件接口</span>：create，delete，open，close，read，write，<span style="color: rgb(222, 87, 0); font-weight: bold;">record open</span></div><div>②<span style="color: rgb(227, 0, 0); font-weight: bold;">文件位置：偏移</span></div><div><br/></div><div>9、①record open：尾部追加写。<span style="color: rgb(222, 87, 0); font-weight: bold;">具有原子性。</span></div><div>②文件被分割为固定大小的<span style="color: rgb(222, 87, 0); font-weight: bold;">chunk</span></div><div>每个chunk会被保存为3个副本（<span style="color: rgb(222, 87, 0); font-weight: bold;">replica</span>），也就是会被保存到3个<span style="color: rgb(222, 87, 0); font-weight: bold;">chunkserver</span>里</div><div><br/></div><div>10、①如果1次写入的数据，超过了1个chunk的边界，那么这次文件写入，也会被分解为多个chunk写入操作</div><div>②<span style="font-weight: bold; color: rgb(222, 87, 0);">没有采用大部分写。</span></div><div>而是全部副本写入成功，才返回成功。</div><div><br/></div><div>11、①修改master上的名字空间：加锁保护</div><div>②租约：</div><div>    【1】<span style="font-weight: bold;">每个chunk都只有1个副本</span>，来管理多个客户端的并发写入。</div><div>    【2】对于1个chunk，master会将一个块租约（chunk lease）授予其中一个副本，<span style="font-weight: bold; color: rgb(50, 135, 18);">由具有租约的副本来管理</span>所有要写入这个chunk的数据</div><div>    【3】首要副本+次要副本</div><div>③<span style="font-weight: bold; color: rgb(222, 87, 0);">变更</span>：</div><div>    【1】对文件的写入</div><div>    【2】<span style="font-weight: bold; color: rgb(222, 87, 0);">变更次序</span>：<span style="font-weight: bold; color: rgb(222, 87, 0);">首要副本</span>管理所有客户端的并发请求，<span style="font-weight: bold;">让所有的请求按照【</span><span style="font-weight: bold; color: rgb(222, 87, 0);">一定的顺序</span><span style="font-weight: bold;">】应用到chunk上。</span></div><div>    【3】write，record append</div><div><br/></div><div>12、</div><div>①写入过程</div><div>（<span style="font-weight: bold; color: rgb(50, 135, 18);">注意：已经把数据都发了之后，提交的时候再确定顺序</span>）</div><div>    【1】询问master，哪个春款server持有chunk的租约</div><div>    【2】客户端<span style="font-weight: bold; color: rgb(222, 87, 0);">向【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">所有</span><span style="font-weight: bold; color: rgb(222, 87, 0);">】的副本，以【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">任意的顺序</span><span style="font-weight: bold; color: rgb(222, 87, 0);">】推送数据</span>。每个chunkServer都会将这些数据缓存在缓冲区</div><div>    【3】首要副本收到【写入请求】，会给这次写入分配一个【<span style="font-weight: bold; color: rgb(222, 87, 0);">连续串行的编号</span>】，<span style="font-weight: bold; color: rgb(50, 135, 18);">然后它会按照【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">这个编号的顺序</span><span style="font-weight: bold; color: rgb(50, 135, 18);">】，将数据写入本地磁盘。</span></div><div>    【4】没有用大多数写。任意一个副本返回错误，都会告知客户端写入失败。</div><div><br/></div><div>13、<span style="font-weight: bold; color: rgb(50, 135, 18);">①record append：这个接口，在论文中被称为原子记录追加（atomic record append）</span></div><div>②相比于12中的写入过程，在步骤【3】时，<span style="font-weight: bold; color: rgb(222, 87, 0);">会检查把这个record追加到尾部会不会超出chunk的边界。</span></div><div>如果会超过，则把这个chunk用其他东西填满，然后把数据添加到下一个chunk上。</div><div><br/></div><div>14、①record append操作只会在一个chunk上生效，<span style="font-weight: bold; color: rgb(222, 87, 0);">从而避免文件操作跨越边界，被分解成多个chunk操作。</span></div><div><span style="font-weight: bold; color: rgb(50, 135, 18);">避免了写入的数据一部分成功、一部分失败的情况。</span></div><div>②如果write操作不跨越边界，那么write操作也满足GFS的原子性。</div><div><br/></div><div>15、</div><div>①【写入的一部分】失败+重试</div><div>    【1】write：    </div><div>            重试。如果在重试成功以前，客户端宕机，就变成永久的不一致了</div><div>    【2】<span style="color: rgb(50, 135, 18); font-weight: bold;">record append ：保证至少有一次原子操作（at least once atomic）</span></div><div><span style="color: rgb(50, 135, 18); font-weight: bold;">        （为了处理P16的并发场景）</span></div><div><span style="font-weight: bold; color: rgb(50, 135, 18);">      </span>      <span style="font-weight: bold; color: rgb(222, 87, 0);">不是在原有的offset处重试，而是在失败的记录后面重试。</span></div><div><span style="font-weight: bold; color: rgb(222, 87, 0);">            这样record append留下的不一致是永久的，并且还会出现重复问题。</span></div><div>②元数据的一致性：</div><div>    单一master，加锁来保护</div><div>③</div><div>    </div><div>16、</div><div>文件数据的一致性</div><div>①</div><div>【1】一致的（consistent）：无论从【<span style="font-weight: bold; color: rgb(222, 87, 0);">哪个副本</span>】读取，所有客户端总是能看到【相同的数据】</div><div>【2】界定的（defined）：在一次数据变更后，<span style="font-weight: bold; color: rgb(222, 87, 0);">这个【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">文件区域</span><span style="font-weight: bold; color: rgb(222, 87, 0);">】是一致的</span>，并且客户端可以看到<span style="font-weight: bold; color: rgb(222, 87, 0);">这次数据变更写入的【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">所有数据</span><span style="font-weight: bold; color: rgb(222, 87, 0);">】。</span></div><div>②<span style="font-weight: bold; color: rgb(50, 135, 18);">并发</span>：一致，但不是界定的。</div><div>        <span style="font-weight: bold;">chunk1和chunk2中包含的，既不是客户端1写入的全部数据，也不是客户端2写入的全部数据。</span></div><div>③record保证区域是界定的，但是界定的区域之间，夹杂着一些不一致的区域。</div><div>    填充【乱七八糟数据】的区域，会被认为是不一致的。</div><div><img src="《分布式算法与一致性》_files/Image [3].png" type="image/png" data-filename="Image.png" width="603"/></div><div><br/></div><div>17、①<span style="font-weight: bold; color: rgb(222, 87, 0);">GFS的松弛一致性模型</span> ：</div><div><span style="font-weight: bold; color: rgb(50, 135, 18);">实际上是一种【</span><span style="color: rgb(50, 135, 18); font-weight: bold;">不一致的模型</span><span style="font-weight: bold; color: rgb(50, 135, 18);">】</span>，或者更准确地说，<span style="font-weight: bold; color: rgb(222, 87, 0);">在【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">一致的数据</span><span style="font-weight: bold; color: rgb(222, 87, 0);">】中间夹杂着【</span><span style="color: rgb(222, 87, 0); font-weight: bold;">不一致的数据</span><span style="font-weight: bold; color: rgb(222, 87, 0);">】</span></div><div>②在这种一致性下，应该如何使用GFS？</div><div>使用建议</div><div>    【<span style="color: rgb(156, 0, 76); font-weight: bold;">1】追加，而不是覆盖</span></div><div><span style="font-weight: bold; color: rgb(156, 0, 76);">    【2】设立检查点：checkPoint</span></div><div><span style="font-weight: bold; color: rgb(156, 0, 76);">    【3】写入自检验：write self-validating</span></div><div><span style="font-weight: bold; color: rgb(156, 0, 76);">    【4】自记录标识：self-identifying</span></div><div><img width="513"></img></div><div><br/></div><div>18、①对于使用者来说，<span style="font-weight: bold; color: rgb(222, 87, 0);">GFS的一致性保证是非常不友好的</span>，很多人第一次看到这样的【一致性保证】都是比较吃惊的。</div><div><span style="font-weight: bold; color: rgb(50, 135, 18);">使用者负担重</span></div><div>②好处：廉价服务器+海量数据</div><div>③<span style="font-weight: bold; color: rgb(222, 87, 0);">因为GFS的主要使用者就是GFS的开发者</span>，他们知道该怎么用GFS</div><div>（<span style="font-weight: bold; color: rgb(50, 135, 18);">BigTable系统是GFS系统的主要调用方</span>）</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 